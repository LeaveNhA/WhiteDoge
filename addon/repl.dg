import '/os'
import '/re'
import '/sys'
import '/types'
import '/builtins'

import '../parse'
import '../compilefd'
import '../compileast'

import '../Name'
import '../Compiler'
import '../LeftBind'
import '../Expression'


_get_input = ns -> except
  _err => import 'readline'
  _err is None =>
    _Readline = (subclass
      readline.Pygments
      readline.Completion
      readline.History
      readline.Readline
    ) where
      completion_regex = re.compile r"\w+'*(?:\.\w+'*)*\.?"
      pygments_lexer   = 'dg'

      display_completions = cmps ~>
        (super _Readline self).display_completions $
          # Strip the dotted path first.
          list $ map (x -> last $ x.split '.') cmps

      #: Complete a variable or an attribute name (i.e. `VAR.VAR....[VAR]`.)
      #: This method simulates `rlcompleter`.
      #: WARNING: this can evaluate arbitrary code via `__getattr__`.
      #:
      #: complete_word :: str -> [str]
      #:
      complete_word = word ~>
        path, dot, word = word.rpartition '.'
        sorted $ map (path + dot +) $ filter (n -> n.startswith word) $
          if path      => @_attributes_of path
             otherwise => set Compiler.prefix | set builtins.__dict__ | set ns

      #: Get a set of attributes of an object. `path` should be a dotted name.
      #:
      #: _attributes_of :: str -> set str
      #:
      _attributes_of = path ~> except
        err =>
          item = eval (compileast $ parse path) ns
          (set $ dir item).union *: (map dir $ type.mro item.__class__)
        err :: Exception => set!

    rdl = _Readline $ readline.Teletype sys.stdin sys.stdout
    rdl.global = ns
    rdl.input
  # Readline is unavailable, fall back to default `input`.
  _err :: ImportError => builtins.input


#: Compile a Python file.
#:
#: compilepyfd :: TextIOBase -> CodeType
#:
compilepyfd = fd filename: '<stream>' -> compile (fd.read -1) filename 'exec'


#: Compile some dg code iff it's a complete statement; return None otherwise.
#:
#: compilerepl :: str -> Maybe CodeObject
#:
compilerepl = source -> except
  e =>
    tree = parse source '<stdin>'
    expr = next $ dropwhile (x -> x :: Expression and not x.closed) $
                  iterate   (x -> last x.args) tree

    # Tap `Return` twice to override any of these checks.
    done = source.endswith '\n' or not
      # There may be an indented block in the next line if
      #     1. the last operator has no right-hand side;
      expr :: LeftBind and not expr.op.norhs or
        #   2. the last expression is accessing a built-in, which
        #      doesn't make sense (unlike a call to that built-in;)
        expr :: Name and not expr.closed and expr.value in Compiler.prefix or
          # 3. the last line of the code is indented.
          (last $ source.rsplit '\n' 1).startswith ' '

    if done => compileast tree
  # Open strings or blocks may be continued, too. (Tapping `Return` won't help.)
  e :: SyntaxError and (head e.args).startswith 'unexpected EOF' => None


#: Execute a single code object as `__main__`.
#:
#: runcode :: CodeType -> object
#:
runcode = code ->
  md = sys.modules !! '__main__' = types.ModuleType '__main__'
  md.__file__ = code.co_filename
  eval code md.__dict__


#: Start a REPL.
#:
#: runrepl :: TextIOBase -> _|_
#:
runrepl = fd environ: (dict __name__: '__main__' builtins: builtins) startup: False ->
  startup => if
    fn = os.environ.get 'PYTHONSTARTUPDG' '' => runcode $ compilefd   (open fn) fn
    fn = os.environ.get 'PYTHONSTARTUP'   '' => runcode $ compilepyfd (open fn) fn

  sys.stdin = fd
  sys.ps1 = getattr sys 'ps1' '>>> '
  sys.ps2 = getattr sys 'ps2' '... '
  _input = _get_input environ

  while True => except
    e => sys.displayhook $ `eval` environ $ next $ dropwhile not
         map compilerepl $ iterate (x -> x + '\n' + _input sys.ps2) $ _input sys.ps1
    e :: EOFError          => raise SystemExit
    e :: SystemExit        => raise e
    e :: KeyboardInterrupt => print '^C' file: sys.stderr
    e => sys.excepthook (type e) e e.__traceback__.tb_next
