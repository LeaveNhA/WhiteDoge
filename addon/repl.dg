import '/os'
import '/sys'
import '/types'
import '/builtins'

import '../parse'
import '../compilefd'
import '../compileast'

import '../Name'
import '../Compiler'
import '../LeftBind'
import '../Expression'


except
  err => import 'readline'
  err :: ImportError => readline = None
  err is None =>
    Reader = subclass readline.History readline.Readline where
      # TODO completion
      # TODO highlighting


#: Compile a Python file.
#:
#: compilepyfd :: TextIOBase -> CodeType
#:
compilepyfd = fd filename: '<stream>' -> compile (fd.read -1) filename 'exec'


#: Compile some dg code iff it's a complete statement; return None otherwise.
#:
#: compilerepl :: str -> Maybe CodeObject
#:
compilerepl = source -> except
  e =>
    tree = parse source '<stdin>'
    expr = next $ dropwhile (x -> x :: Expression and not x.closed) $
                  iterate   (x -> last x.args) tree

    # Tap `Return` twice to override any of these checks.
    done = source.endswith '\n' or not
      # There may be an indented block in the next line if
      #     1. the last operator has no right-hand side;
      expr :: LeftBind and not expr.op.norhs or
        #   2. the last expression is accessing a built-in, which
        #      doesn't make sense (unlike a call to that built-in;)
        expr :: Name and not expr.closed and expr.value in Compiler.prefix or
          # 3. the last line of the code is indented.
          (last $ source.rsplit '\n' 1).startswith ' '

    if done => compileast tree
  # Open strings or blocks may be continued, too. (Tapping `Return` won't help.)
  e :: SyntaxError and (head e.args).startswith 'unexpected EOF' => None


#: Execute a single code object as `__main__`.
#:
#: runcode :: CodeType -> object
#:
runcode = code ->
  md = sys.modules !! '__main__' = types.ModuleType '__main__'
  md.__file__ = code.co_filename
  eval code md.__dict__


#: Start a REPL.
#:
#: runrepl :: TextIOBase -> _|_
#:
runrepl = fd environ: (dict __name__: '__main__' builtins: builtins) startup: False ->
  startup => if
    fn = os.environ.get 'PYTHONSTARTUPDG' '' => runcode $ compilefd   (open fn) fn
    fn = os.environ.get 'PYTHONSTARTUP'   '' => runcode $ compilepyfd (open fn) fn

  sys.stdin = fd
  sys.ps1 = getattr sys 'ps1' '>>> '
  sys.ps2 = getattr sys 'ps2' '... '

  _input = if
    # TODO: syntax highlighting
    readline  => (Reader $ readline.Teletype fd sys.stdout).input
    otherwise => input

  while True => except
    e => sys.displayhook $ `eval` environ $ next $ dropwhile not
         map compilerepl $ iterate (x -> x + '\n' + _input sys.ps2) $ _input sys.ps1
    e :: EOFError          => raise SystemExit
    e :: SystemExit        => raise e
    e :: KeyboardInterrupt => print '^C' file: sys.stderr
    e => sys.excepthook (type e) e e.__traceback__.tb_next
