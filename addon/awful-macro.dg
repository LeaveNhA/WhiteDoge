import '/sys'
import '/builtins'
import '/readline'
import '/traceback'


colored = except
  # `clint` recommended for maximum awesomeness.
  err => import '/clint/textui/colored'
  err => subclass object where
    magenta = cyan = green =
     yellow = blue = white =
      black = red  = staticmethod $ x -> x


console_width = except
  err => import '/clint/textui/cols/console_width'
  err => kwargs -> 80


#: Format a full traceback.
#:
#: tbformat :: type Exception TracebackType -> str
#:
tbformat = t value trace -> '\n'.join $ list'
  if value :: SyntaxError => tbformat.syntax t value
     otherwise            => tbformat.error  t value
  '\n'.join $ map tbformat.item $ reversed $ traceback.extract_tb trace


#: Format one line of a traceback.
#:
#: item :: (str, int, str, Maybe str) -> str
#:
tbformat.item = (f, ln, fn, txt) ->
  # Do not show function name at top level.
  fn  = if fn == '<module>' or not fn => ''
           otherwise                  => ': ' + fn
  # The file may not exist.
  txt = if txt is None => ''
           otherwise   => ': ' + txt
  # Contents of the file is the most useless info here.
  # We'll truncate it to fit the line into the console.
  width  = console_width dict!
  length = 8 + len f + len (str ln) + len fn
  # However, it only makes sense if we have more than 5 characters.
  # Otherwise, better hide it completely.
  txt = if length > width - 5       => ''
           length > width - len txt => txt !! slice 0 (width - length - 3) + '...'
           otherwise => txt
  '  {} line {}{}{}'.format (colored.yellow f) (colored.cyan $ str ln) fn txt


#: Format a standard error message.
#:
#: error :: type Exception -> str
#:
tbformat.error = t value -> '{}: {}'.format (colored.red t.__name__) value


#: Like `error`, only for `SyntaxError`s. Should display where the error is.
#:
#: syntax :: type SyntaxError -> str
#:
tbformat.syntax = t value -> '{}: {}\n{}'.format
  colored.red t.__name__
  value.msg
  tbformat.item (value.filename, value.lineno, txt, None) where txt = if
    not value.text or value.offset > len value.text => ''
    otherwise => '{}{}{}\n{}^'.format
      str.lstrip  $ value.text !! slice None (value.offset - 1)
      colored.red $ value.text !! (value.offset - 1)
      str.rstrip  $ value.text !! slice value.offset None
      ' ' * (len (value.filename + str value.lineno) + 9 + value.offset)


sys.displayhook = v -> if
  # `exit` and `quit` should not need to be called when used from a REPL.
  v is exit => v 0
  v is quit => v 0
  v is None => None
  otherwise =>
    text = str sys.ret + repr v
    except e => print text
           e :: UnicodeEncodeError => print $
             enc = text.encode sys.stdout.encoding 'backslashreplace'
             enc.decode sys.stdout.encoding 'strict'
    builtins._ = v


sys.excepthook = t v tb original: sys.excepthook -> except
  err => print file: sys.stderr $ tbformat t v tb
  # *Somebody* will surely find a way to break `Traceback`.
  # Note that this will display the original traceback, too.
  err => original (type err) err err.__traceback__


sys.ps1 = 'dg $ '
sys.ps2 = '   | '
sys.ret = colored.green  '   = '
builtins._ = None
