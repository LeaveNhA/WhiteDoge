# String representation of the variable on the left side of
# the innermost assignment or None.
Generator.var = None


LazyInteger = __int__ ->
  '''An object that can be converted into an integer on demand.

    type LazyInteger { __int__ :: -> int }

  '''
  call $ subclass object


Generator.get_freevar = name ~>
  '''Fetch the index of a free variable.

    `cellvars` and `freevars` share the index space, so
    this needs to be deferred until compilation time.

  '''
  LazyInteger $ _ i: (@freevars name) -> len @cellvars + i


Generator.load = v ~>
  '''Push the value assigned to some name onto the value stack.

    load :: str -> a

  '''
  @stackperm +1

  if v in @cellvars => @add_opcode 'LOAD_DEREF'  $ @cellvars v
     v in @varnames =>
       (@f_locals !! v).add (len @bytecode, dis.opmap !! 'LOAD_DEREF')
       @add_opcode 'LOAD_FAST' $ @varnames v
     v in @enclosed => @add_opcode 'LOAD_DEREF'  $ @get_freevar v
     @slowlocals    => @add_opcode 'LOAD_NAME'   $ @names v
     otherwise      => @add_opcode 'LOAD_GLOBAL' $ @names v


Generator.store = v ~>
  '''Store the value on top of the stack in a variable.

    store :: str -> a

  '''
  @currstack -= 1

  if v in @cellvars => @add_opcode 'STORE_DEREF' $ @cellvars    v
     v in @enclosed => @add_opcode 'STORE_DEREF' $ @get_freevar v
     @slowlocals    => @add_opcode 'STORE_NAME'  $ @names v
     otherwise      =>
       (@f_locals !! v).add (len @bytecode, dis.opmap !! 'STORE_DEREF')
       @add_opcode 'STORE_FAST' $ @varnames v


Generator.load_closure = v ~>
  '''Load a cell object referencing some variable.

    load_closure :: str -> a

  '''
  for (i, c) in @f_locals !! v =>
    @bytecode !! i = c, @cellvars v

  @stackperm +1
  @add_opcode 'LOAD_CLOSURE' $ if v in @cellvars => @cellvars v
                                  v in @varnames => @cellvars v
                                  otherwise      => @get_freevar v


Generator.child_name = fallback ~>
  '''Make a name for a child code object.

    fallback -- the name to use if the code object is not assigned to anything.

    child_name :: str -> str

  '''
  name = @var or fallback
  if str.isidentifier name or (name.startswith '<' and name.endswith '>') => name
     otherwise => '<' + name + '>'
