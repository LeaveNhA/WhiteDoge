# These constants, unless redefined in a function, will
# be loaded with LOAD_CONST, not LOAD_GLOBAL.
# FIXME what if one of them is redefined in a global namespace?
CONSTANTS = dict True: True False: False None: None otherwise: True

# String representation of the variable on the left side of
# the innermost assignment or None. (Used to calculate `name` and `qualname`.)
Generator.var = None


Generator.load_const = x ~>
  '''Push `x` onto the value stack.

    Technically, `x` can be anything, but most types would make
    the code object unmarshallable.

    load_const :: object -> a

  '''
  @stackperm +1
  @add_opcode 'LOAD_CONST' $ @consts (x, type x)


Generator.load = v ~>
  '''Push the value assigned to some name onto the value stack.

    load :: str -> a

  '''
  @stackperm +1

  if v in @cellvars => @add_opcode 'LOAD_DEREF'  $ @cellvars v
     v in @varnames =>
       (@fastlocals !! v).add (len @bytecode, dis.opmap !! 'LOAD_DEREF')
       @add_opcode 'LOAD_FAST' $ @varnames v
     v in @enclosed => @add_opcode 'LOAD_DEREF'  $ @freevars v
     v in CONSTANTS => @load_const $ CONSTANTS !! v
     @function      => @add_opcode 'LOAD_GLOBAL' $ @names    v
     otherwise      => @add_opcode 'LOAD_NAME'   $ @names    v


Generator.store = v ~>
  '''Store the value on top of the stack in a variable.

    store :: str -> a

  '''
  @currstack -= 1

  if v in @cellvars => @add_opcode 'STORE_DEREF' $ @cellvars v
     v in @enclosed => @add_opcode 'STORE_DEREF' $ @freevars v
     @function      =>
       (@fastlocals !! v).add (len @bytecode, dis.opmap !! 'STORE_DEREF')
       @add_opcode 'STORE_FAST' $ @varnames v
     otherwise      => @add_opcode 'STORE_NAME'  $ @names    v


Generator.load_closure = v ~>
  '''Load a cell object referencing some variable.

    load_closure :: str -> a

  '''
  for (i, c) in @fastlocals !! v => @bytecode !! i = c, @cellvars v
  @stackperm +1
  @add_opcode 'LOAD_CLOSURE' $ if v in @cellvars => @cellvars v
                                  v in @varnames => @cellvars v
                                  otherwise      => @freevars v


Generator.child_name = fallback ~>
  '''Make a name for a child code object.

    fallback -- the name to use if the code object is not assigned to anything.

    child_name :: str -> str

  '''
  name = @var or fallback
  if str.isidentifier name or (name.startswith '<' and name.endswith '>') => name
     otherwise => '<' + name + '>'
