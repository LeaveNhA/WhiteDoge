Compiler.prefix !! 'raise' = ARGCOUNT 1 $ f (exc,) ~>
  @pushast exc
  @append  'RAISE_VARARGS' 1 delta: -1 # There's nothing on the stack, but nobody will notice.


Compiler.prefix !! 'except' = ARGCOUNT 1 max: ANY $ f cases ~>
  (name, try), *xs = if_syntax cases
  @pushconst None
  @depth +7  # A very pessimistic estimate.
  if xs and head (last xs) == 'finally' => @except_finally name try xs $ snd $ xs.pop -1
     otherwise                          => @except_main    name try xs
  @depth -7


Compiler.except_finally = name try cases finally ~>
  # Blindly copied from Python by `diff`ing
  # disassembly of code with `finally` and without one.
  with @jump 'SETUP_FINALLY' =>
    @except_main name try cases
    @append 'POP_BLOCK'
    @pushconst None
  @pushast finally
  @append 'POP_TOP'     delta: -1
  @append 'END_FINALLY' delta: -1


Compiler.except_main = name try cases ~>
  main = @jump 'SETUP_EXCEPT'
  @pushast try
  @append 'ROT_TWO'   delta: +0
  @append 'POP_BLOCK' delta: -1
  # There was no exception, we'll store None instead.
  # The second one will be used to skip over POP_EXCEPT or
  # consumed by END_FINALLY.
  @pushconst None
  @pushconst None
  @popast name

  with @jump 'JUMP_FORWARD' =>
    # Finishing SETUP_EXCEPT with an exception pushes
    # 3 items onto the stack: traceback, value, type.
    # Value needs to be stored in `name`.
    main.set
    @append 'ROT_TWO' delta: +0
    @append 'DUP_TOP' delta: +1
    @popast name
    @append 'ROT_TWO' delta: +0
    @pushconst True  # This will trigger POP_EXCEPT.  

  jumps = list
    None where for (cond, action) in cases =>
      @pushast cond
      with @jump 'POP_JUMP_IF_FALSE' delta: -1 =>
        @pushast action
        yield $ @jump 'JUMP_FORWARD' delta: -1

  # Disable POP_EXCEPT by popping True off the stack.
  # Only happens if there was an exception.
  with @jump 'JUMP_IF_FALSE_OR_POP' delta: -1 => None
  # This will re-raise the exception if there was one.
  # Otherwise, it will pop None off the stack.
  @append 'END_FINALLY' delta: -1

  with @jump 'JUMP_FORWARD' =>
    # If a handler was triggered, there's now a return value
    # on top of the stack. It needs to be stored for safekeeping.
    for j in jumps => j.set
    @append 'STORE_FAST' $ @varnames !! '<except-result>'
    # Traceback, value, and type may still be on stack.
    # They didn't stop existing or anything.
    with @jump 'POP_JUMP_IF_FALSE' => @append 'POP_EXCEPT'
    @append 'POP_TOP'  # There goes the result of the try clause.
    @append 'LOAD_FAST'   $ @varnames !! '<except-result>'
    @append 'DELETE_FAST' $ @varnames !! '<except-result>'
