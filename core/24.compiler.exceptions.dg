except_syntax = cases ->
  pairs = if_syntax cases
  pairs, if len pairs > 1 and head (last pairs) == 'finally' => pairs.pop!
            otherwise => None, None


Generator.prefix !! 'raise' = f args ~>
  args = unpack f args $ exception cause: None ->
    if cause is None => tuple' exception
       otherwise     => exception, cause
  exhaust $ map @load_ast args
  @add_opcode 'RAISE_VARARGS' (len args)
  @currstack -= len args
  @load_const None  # We've got to return something.


Generator.prefix !! 'except' = f cases ~>
  ((name, try), *cases), (has_finally, finally) = except_syntax $ ensure f cases
  @load_const None
  @stackperm +7  # A very pessimistic estimate.
  if has_finally => @except_finally name try cases finally
     otherwise   => @except_main    name try cases
  @currstack -= 7


Generator.except_finally = name try cases finally ~>
  # Blindly copied from Python by `diff`ing
  # disassembly of code with `finally` and without one.
  with @setup 'finally' =>
    @except_main name try cases
    @add_opcode 'POP_BLOCK'
    @load_const None
  @load_ast finally
  @add_opcode 'POP_TOP'
  @add_opcode 'END_FINALLY'
  @currstack -= 1


Generator.except_main = name try cases ~>
  main = @setup 'except'
  @load_ast try
  @add_opcode 'ROT_TWO'
  @add_opcode 'POP_BLOCK'
  @currstack -= 1
  # There was no exception, we'll store None instead.
  # The second one will be used to skip over POP_EXCEPT or
  # consumed by END_FINALLY.
  @load_const None
  @load_const None
  @store_ast name

  with @jump reverse: False =>
    # Finishing SETUP_EXCEPT with an exception pushes
    # 3 items onto the stack: traceback, value, type.
    # Value needs to be stored in `name`.
    main.set
    @add_opcode 'ROT_TWO'
    @add_opcode 'DUP_TOP'
    @stackperm +1
    @store_ast name
    @add_opcode 'ROT_TWO'
    # This will trigger POP_EXCEPT.
    @load_const True

  jumps = list
    None where for (cond, action) in cases =>
      @load_ast cond
      @currstack -= 1
      with @pop_jump_if False reverse: False =>
        @load_ast action
        @currstack -= 1
        yield $ @jump reverse: False

  # This will re-raise the exception if there was one.
  # Otherwise, it will pop None off the stack.
  with @jump_or_pop_if False reverse: False => None
  @add_opcode 'END_FINALLY'
  @currstack -= 1

  with @jump reverse: False =>
    # If a handler was triggered, there's now a return value
    # on top of the stack. It needs to be stored for safekeeping.
    for j in jumps => j.set
    @add_opcode 'STORE_DEREF' $ @cellvars '<except-result>'
    # Traceback, value, and type may still be on stack.
    # They didn't stop existing or anything.
    with @pop_jump_if False reverse: False => @add_opcode 'POP_EXCEPT'
    @add_opcode 'POP_TOP'  # There goes the result of the try clause.
    @add_opcode 'LOAD_DEREF'   $ @cellvars '<except-result>'
    @add_opcode 'DELETE_DEREF' $ @cellvars '<except-result>'
