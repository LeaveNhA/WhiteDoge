except_syntax = cases ->
  pairs = if_syntax cases
  pairs, if len pairs > 1 and head (last pairs) == 'finally' => pairs.pop!
            otherwise => None, None


Generator.prefix !! 'raise' = f args ~>
  args = unpack f args $ exception cause: None ->
    if cause is None => tuple' exception
       otherwise     => exception, cause
  exhaust $ map @load_ast args
  @add_opcode 'RAISE_VARARGS' (len args)
  @currstack -= len args
  @load_const None  # We've got to return something.


Generator.prefix !! 'except' = f cases ~>
  ((name, try), *cases), (has_finally, finally) = except_syntax $ ensure f cases
  @load_const None
  @stackperm +7  # A very pessimistic estimate.
  if has_finally => @except_finally name try cases finally
     otherwise   => @except_main    name try cases
  @currstack -= 7


Generator.except_finally = name try cases finally ~>
  # Blindly copied from Python by `diff`ing
  # disassembly of code with `finally` and without one.
  with @setup 'finally' =>
    @except_main name try cases
    @add_opcode 'POP_BLOCK'
    @load_const None
  @load_ast finally
  @add_opcode 'POP_TOP'
  @add_opcode 'END_FINALLY'
  @currstack -= 1


Generator.except_main = name try cases ~>
  main = @setup 'except'
  # Replace that None with the value returned by `try_`
  # to fool the POP_BLOCK instruction.
  @load_ast try
  @add_opcode 'ROT_TWO'
  @add_opcode 'POP_TOP'
  @add_opcode 'POP_BLOCK'
  @currstack -= 1
  # There was no exception, so we'll push two `None`s instead.
  # Why two? Because why the fuck not. (Ok, seriously,
  # one of them will be stored in `name`, while the second
  # will be popped by END_FINALLY.
  @load_const None
  @load_const None
  else = @jump reverse: False
  # Finishing SETUP_EXCEPT with an exception pushes
  # 3 items onto the stack: (traceback, value, type).
  # (CPython sure is strange. Both traceback and type
  # can be derived from value.)
  main.set
  @add_opcode 'ROT_TWO'   #=> (traceback, type, value)
  @add_opcode 'DUP_TOP'   #=> (traceback, type, value, value)
  @add_opcode 'ROT_THREE' #=> (traceback, value, type, value)
  else.set
  @store_ast name

  jumps = list $ map
    (cond, action) ->
      @load_ast cond
      with @pop_jump_if False reverse: False =>
        @currstack -= 1
        @load_ast action
        @currstack -= 1
        @jump reverse: False
    cases

  # This will re-raise the exception if nothing matched
  # (and there was an exception. And there is no `finally` clause.)
  @add_opcode 'END_FINALLY'
  @currstack -= 1
  # No point in doing anything else. Either the exception was re-raised,
  # or there's no `except` handler to pop.
  with @jump reverse: False =>
    # If a handler was triggered, there's now a return value
    # on top of the stack. It needs to be stored for safekeeping.
    for j in jumps => j.set
    @add_opcode 'STORE_DEREF' $ @cellvars '<except-result>'
    # There's still either a `None` or a subclass of `Exception` on the stack.
    # It didn't stop existing or anything.
    @add_opcode 'DUP_TOP'
    @load_const None
    # The point is, if there was an exception, we need to do POP_EXCEPT.
    @add_opcode 'COMPARE_OP' $ dis.cmp_op.index 'is'
    @currstack -= 1
    with @pop_jump_if True reverse: False => @add_opcode 'POP_EXCEPT'
    # Now we can restore that value.
    @add_opcode 'POP_TOP'
    @add_opcode 'LOAD_DEREF'   $ @cellvars '<except-result>'
    @add_opcode 'DELETE_DEREF' $ @cellvars '<except-result>'
