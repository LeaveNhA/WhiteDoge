INFIXN = set' 'and' 'in' 'is' 'or' 'where'
VARARY = set' ',' '\n' ''
NOLHS  = set' '@' '~'
NORHS  = set' '!'
FLAGS  = dict' ('for', 1) ('while', 1) ('with', 1) ('if', 2) ('except', 2)

STRENGTH = dict'
  '@',     ( 5,    5)    # attribute of `self`
  '.',     ( 0,    0)    # getattr
  '!.',    ( 0,    0)    # call with no arguments, then getattr
  '!',     ( 0,   -10)   # call with no arguments
  ':',     ( 0,   -10)   # keyword argument
  '',      (-20,  -20)   # call with an argument
  '!!',    (-30,  -30)   # container subscription (i.e. `a[b]`)
  '**',    (-30,  -40)   # exponentiation
  '*',     (-50,  -50)   # multiplication
  '/',     (-50,  -50)   # fp division
  '//',    (-50,  -50)   # int division
  '%',     (-50,  -50)   # modulus
  '+',     (-60,  -60)   # addition
  '-',     (-60,  -60)   # subtraction
  '<',     (-80,  -80)   # less than
  '<=',    (-80,  -80)   # ^ or equal
  '>',     (-80,  -80)   # greater than
  '>=',    (-80,  -80)   # ^ or equal
  '==',    (-80,  -80)   # equal
  '!=',    (-80,  -80)   # not ^
  'is',    (-80,  -80)   # occupies the same memory location as
  'in',    (-80,  -80)   # is one of the elements of
  '<<',    (-100, -100)  # *  2 **
  '>>',    (-100, -100)  # // 2 **
  '&',     (-110, -110)  # bitwise and
  '^',     (-120, -120)  # bitwise xor
  '|',     (-130, -130)  # bitwise or
  'and',   (-140, -140)  # B if A else A
  'or',    (-150, -150)  # A if A else B
  '$',     (-150, -160)  # call with one argument and no f-ing parentheses
  '->',    (-25,  -180)  # a function
  '~>',    (-25,  -180)  # a method (i.e. a function with `self` as an argument)
  ',',     (-170, -170)  # a tuple
  '=',     (-170, -180)  # assignment
  '!!=',   (-170, -180)  # in-place versions of some of the other functions
  '+=',    (-170, -180)
  '-=',    (-170, -180)
  '*=',    (-170, -180)
  '**=',   (-170, -180)
  '/=',    (-170, -180)
  '//=',   (-170, -180)
  '%=',    (-170, -180)
  '&=',    (-170, -180)
  '^=',    (-170, -180)
  '|=',    (-170, -180)
  '<<=',   (-170, -180)
  '>>=',   (-170, -180)
  'where', (-170, -180)  # with some stuff that is not visible outside of that expression
  'for',   (-180, -190)  # evaluate stuff for each item in an iterable
  'while', (-180, -190)  # evaluate stuff until condition becomes false
  'with',  (-180, -190)
  '=>',    (-180, -190)  # if-then
  '\n',    (-230, -230)  # do A then B


Node = subclass object where
  # These are only used by `Name`s.
  closed = False  # :: bool -- whether the node is parenthesized
  indent = False  # :: bool -- whether the node is intented relative to the surroundings
  infix  = False  # :: bool -- whether the node is an infix `Name`
  nolhs  = False  # :: bool -- whether an `infix` `Name` can only be right-bound
  norhs  = False  # :: bool -- whether an `infix` `Name` can only be left-bound
  varary = False  # :: bool -- whether an `infix` `Name` accepts 3+ arguments
  flags  = 0      # special null denotations

  __init__ = self @loc -> None
  __repr__ = self      -> '<Node: nil>'


Name = subclass Node where
  __init__ = self @loc infix @value ->
    @infix  = @value in INFIXN or infix
    @nolhs  = @value in NOLHS
    @norhs  = @value in NORHS
    @varary = @value in VARARY
    @flags  = FLAGS.get @value 0
    None

  __eq__   = self x -> @value == x
  __hash__ = self   -> hash @value
  __repr__ = self   -> if
    @closed   => '(' + @value + ')'
    otherwise =>       @value

  #: Whether this (infix) node has priority over the other one.
  #:
  #: `a R b Q c` <=> `a R (b Q c)` if left binding strength of `Q`
  #: is higher than right binding strength of `R`, `(a R b) Q c` otherwise.
  #:
  __gt__ = over ~> if
    over :: str => STRENGTH.get @value (-70, -70) !! 0 > STRENGTH.get over (-70, -70) !! 1
    otherwise   => self > over.value
  __le__ = over ~> not $ self > over
  __lt__ = over ~> not $ self > over


Expression = subclass Node where
  __init__ = self @loc @op *: args -> None where @args = list args
  __repr__ = self -> '(' + (repr @op or ' ').join (map repr @args) + ')'


Constant = subclass Node where
  __init__ = self @loc @value -> None
  __repr__ = self -> repr @value


LeftBind = subclass Expression where
  __repr__ = self -> '({[0]!r} {!r})'.format @args @op


RightBind = subclass Expression where
  __repr__ = self -> '({!r} {[0]!r})'.format @op @args


Ending = subclass Node where
  __init__ = self @loc @value -> None
  __repr__ = self -> '<Ending: {!r}>'.format @value
