func_call_args = xs ->
  '''Parse function call arguments.

    func_call_args :: [Node] -> ([Node], {str: Node}, Maybe Node, Maybe Node)

  '''
  a   = list!
  kw  = dict!
  va  = None
  vkw = None

  for x in xs => if
    x :: Expression and x.op == ':' => if
      # *: x => take the rest of the positional arguments from x.
      # FIXME should allow more than one (*: x) by joining x's with
      #       `itertools.chain`. Probably.
      fst x.args == '*' =>
        va => Parser.error 'can only have one (*: x)' x.loc
        va = snd x.args
      # **: x => take the rest of the keyword arguments from x.
      # FIXME same for (**: xs), but with `dict.update`.
      fst x.args == '**' =>
        vkw => Parser.error 'can only have one (**: x)' x.loc
        vkw = snd x.args
      # a: b => pass `b` as an argument named "a".
      fst x.args :: Name => kw !! (fst x.args).value = snd x.args
      # Pattern-match keyword names, maybe? By converting their
      # ASTs to strings or something? But what if the argument
      # is not unique?
      otherwise => Parser.error 'keywords should be identifiers' x.loc
    otherwise => a.append x

  len a  > 255 => Parser.error 'too many arguments'         (fst xs).loc
  len kw > 255 => Parser.error 'too many keyword arguments' (fst xs).loc
  a, kw, va, vkw


func_def_args = xs ->
  '''Parse an argument specification.

    func_def_args :: Maybe Node -> ([str], [str], [Node], {str: Node}, [str], [str], {str: Node})

  '''
  a    = list!  # positional
  kw   = list!  # keyword-only
  da   = list!  # default values
  dkw  = dict!  # default values for keyword-only arguments
  va   = list!  # varargs (a singleton)
  vkw  = list!  # varkwargs (a singleton)
  add  = dict!  # (name -> pattern) mapping
  vars = set!

  not $ xs is None =>
    # Pass `None` if there are no arguments.
    # (e.g. there is nothing before the `->`)
    pattern = x -> if
      x :: Name and not (x.value in vars) =>
        # Python requires all argument names to be unique,
        # so duplicate names are treated as patterns.
        vars.add x.value
        x.value
      otherwise =>
        name = '<{}>'.format $ len add
        add !! name = x
        name

    data = if xs :: Expression and not xs.closed and xs.op == '' => xs.args
              otherwise                                          => list' xs

    for x in data => if
      x :: Expression and x.op == ':' =>
        k, x = x.args
        if # Once again, (*: x) => the rest of positional arguments.
           # This time there should only be one for sure.
           k == '*' =>
             va => Parser.error 'can only have one (*: x)' x.loc
             va.append $ pattern x
           # (**: x) => the rest of keyword arguments.
           k == '**' =>
             vkw => Parser.error 'can only have one (**: x)' x.loc
             vkw.append $ pattern x
           # If there was a (*: x) before this argument,
           # it should only be accessible by a keyword.
           va =>
             k :: Name or Parser.error 'keywords cannot be pattern-matched' k.loc
             kw.append k.value
             dkw !! k.value = x
           # If not, this is a positional keyword with a default value.
           otherwise =>
             a.append $ pattern k
             da.append x
      # Keyword-only arguments are not required to have a default value.
      va => kw.append $ pattern x
      # Positional ones that come after the first one with a default value set
      # are, though.
      da => Parser.error 'this argument must have a default value' x.loc
      otherwise => a.append $ pattern x

    len a  > 255 => Parser.error 'too many arguments'         xs.loc
    len kw > 255 => Parser.error 'too many keyword arguments' xs.loc
  a, kw, da, dkw, va, vkw, add


Generator.make_function = code defaults kwdefaults ~>
  '''Freeze a `Generator` object and create a function out of it.

    make_function :: Generator [Node] {str: Node} -> a

  '''
  const = code.frozen
  name  = code.qualname

  exhaust $ map @load_key     kwdefaults.items!
  exhaust $ map @load_ast     defaults
  exhaust $ map @load_closure const.co_freevars

  @stackperm +1
  @add_opcode 'BUILD_TUPLE' $ len const.co_freevars
  @currstack -= len const.co_freevars
  @load_const const
  @load_const name
  @add_opcode 'MAKE_CLOSURE' $ 0 + len defaults + 256 * len kwdefaults
  @currstack -= len defaults + 2 * len kwdefaults + 2


Generator.infixbind = kwd pos f arg ~>
  '''Default infix bind implementation.

    `x R` <=> `y -> x R y`
    `R x` <=> `y -> y R x`

    infixbind :: str str Node Node -> a

  '''
  f.value in @prefix and not (f.value in builtins.__dict__) =>
    # Note that partial binding of macros does not actually use
    # runtime functions (as `load_call` will prefer compile-time ones.)
    # Still, this is a pretty good method of checking if
    # someone's attempting to partially bind assignment operators, etc.
    Parser.error 'this operator is unbindable' f.loc

  c = Generator ('<bound {.value}>'.format f) True (tuple' pos) (tuple' kwd) cell: self
  c.load_call f (Name '<L>') (Name '<R>')
  c.add_opcode 'RETURN_VALUE'
  @make_function c tuple! $ dict' (kwd, arg)


Generator.load_function = args body ~>
  '''Create a function.

    load_function :: Node Node -> a

  '''
  a, kw, da, dkw, va, vkw, patterns = func_def_args args
  g = Generator (@child_name '<lambda>') True a kw va vkw self

  for (name, pattern) in patterns.items! =>
    g.load name
    g.store_ast pattern

  g.load_ast body
  g.add_opcode 'RETURN_VALUE'
  @make_function g da dkw


Generator.load_fnmethod = xs body ~>
  '''Create a method (a function with an additional argument named "self".)

    load_fnmethod :: Node Node -> a

  '''
  if
    xs is None =>
      @stackperm +1
      @add_opcode 'LOAD_GLOBAL' $ @names 'property'
      @load_function (Name 'self') body
      @add_opcode 'CALL_FUNCTION' 1
      @currstack -= 1

    xs :: Expression and not xs.closed and xs.op == '' =>
      xs.args.insert 0 (Name 'self')
      @load_function xs body

    otherwise =>
      @load_function (Expression (Name '') (Name 'self') xs) body


Generator.prefix !! '->' = f q ~> @load_function *: (ensure f q 2 2)
Generator.prefix !! '~>' = f q ~> @load_fnmethod *: (ensure f q 2 2)
Generator.infixl !! '->' = f q ~> @load_call f q (Constant None at: f.loc)
Generator.infixl !! '~>' = f q ~> @load_call f q (Constant None at: f.loc)
Generator.infixr !! '->' = f q ~> @load_call f None q
Generator.infixr !! '~>' = f q ~> @load_call f None q
