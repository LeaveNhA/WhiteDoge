func_call_args = xs ->
  '''Parse function call arguments.

    func_call_args :: [Node] -> ([Node], {str: Node}, Maybe Node, Maybe Node)

  '''
  a   = list!
  kw  = dict!
  va  = None
  vkw = None

  for x in xs => if
    x :: Expression and x.op == ':' => if
      # *: x => take the rest of the positional arguments from x.
      # FIXME should allow more than one (*: x) by joining x's with
      #       `itertools.chain`. Probably.
      fst x.args == '*' =>
        va => Parser.error 'can only have one (*: x)' x.loc
        va = snd x.args
      # **: x => take the rest of the keyword arguments from x.
      # FIXME same for (**: xs), but with `dict.update`.
      fst x.args == '**' =>
        vkw => Parser.error 'can only have one (**: x)' x.loc
        vkw = snd x.args
      # a: b => pass `b` as an argument named "a".
      fst x.args :: Name => kw !! (fst x.args).value = snd x.args
      # Pattern-match keyword names, maybe? By converting their
      # ASTs to strings or something? But what if the argument
      # is not unique?
      otherwise => Parser.error 'keywords should be identifiers' x.loc
    otherwise => a.append x

  len a  > 255 => Parser.error 'too many arguments'         (fst xs).loc
  len kw > 255 => Parser.error 'too many keyword arguments' (fst xs).loc
  a, kw, va, vkw


func_def_args = xs ->
  '''Parse an argument specification.

    func_def_args :: Maybe Node -> ([str], [str], [Node], {str: Node}, [str], [str], {str: Node})

  '''
  a    = list!  # positional
  kw   = list!  # keyword-only
  da   = list!  # default values
  dkw  = dict!  # default values for keyword-only arguments
  va   = list!  # varargs (a singleton)
  vkw  = list!  # varkwargs (a singleton)
  add  = dict!  # (name -> pattern) mapping
  vars = set!

  not $ xs is None =>
    # Pass `None` if there are no arguments.
    # (e.g. there is nothing before the `->`)
    pattern = x -> if
      x :: Name and not (x.value in vars) =>
        # Python requires all argument names to be unique,
        # so duplicate names are treated as patterns.
        vars.add x.value
        x.value
      otherwise =>
        name = '<{}>'.format $ len add
        add !! name = x
        name

    data = if xs :: Expression and not xs.closed and xs.op == '' => xs.args
              otherwise                                          => list' xs

    for x in data => if
      x :: Expression and x.op == ':' =>
        k, x = x.args
        if # Once again, (*: x) => the rest of positional arguments.
           # This time there should only be one for sure.
           k == '*' =>
             va => Parser.error 'can only have one (*: x)' x.loc
             va.append $ pattern x
           # (**: x) => the rest of keyword arguments.
           k == '**' =>
             vkw => Parser.error 'can only have one (**: x)' x.loc
             vkw.append $ pattern x
           # If there was a (*: x) before this argument,
           # it should only be accessible by a keyword.
           va =>
             k :: Name or Parser.error 'keywords cannot be pattern-matched' k.loc
             kw.append k.value
             dkw !! k.value = x
           # If not, this is a positional keyword with a default value.
           otherwise =>
             a.append $ pattern k
             da.append x
      # Keyword-only arguments are not required to have a default value.
      va => kw.append $ pattern x
      # Positional ones that come after the first one with a default value set
      # are, though.
      da => Parser.error 'this argument must have a default value' x.loc
      otherwise => a.append $ pattern x

    len a  > 255 => Parser.error 'too many arguments'         xs.loc
    len kw > 255 => Parser.error 'too many keyword arguments' xs.loc
  a, kw, da, dkw, va, vkw, add
