import '/builtins'
import '/operator'
import '/functools'
import '/itertools'
import '/collections'

builtins.__dict__.update locals! where
  set'   = *: xs       -> set  xs
  list'  = *: xs       -> list xs
  dict'  = *: xs **: k -> dict xs **: k
  tuple' = (,) = *: xs -> xs

  call  = (!) = ($) = f *: a **: k -> f *: a **: k
  bind  = functools.partial
  flip  = f -> x y -> f y x
  (<-)  = f g -> *: a **: k -> f $ g *: a **: k

  (..)  = range
  (...) = Ellipsis
  (::)  = isinstance
  (->)  = -> None
  (~>)  = ~> None
  (:)   = a b -> itertools.chain (list' a) b
  (in)  = a b -> a in b
  (is)  = operator.is_
  (not) = operator.not_
  (<)   = operator.lt
  (<=)  = operator.le
  (==)  = operator.eq
  (!=)  = operator.ne
  (>=)  = operator.ge
  (>)   = operator.gt
  (~)   = operator.invert
  (+)   = operator.add
  (-)   = operator.sub
  (*)   = operator.mul
  (**)  = operator.pow
  (/)   = operator.truediv
  (//)  = operator.floordiv
  (%)   = operator.mod
  (&)   = operator.and_
  (^)   = operator.xor
  (|)   = operator.or_
  (<<)  = operator.lshift
  (>>)  = operator.rshift
  (!!)  = operator.getitem
  (!!~) = operator.delitem

  take      = n xs -> itertools.islice xs None n
  drop      = n xs -> itertools.islice xs n None
  takewhile = itertools.takewhile
  dropwhile = itertools.dropwhile
  exhaust   = x -> collections.deque x maxlen: 0
  iterate   = f x -> while True =>
    yield x
    x = f x

  foldl  = f st xs -> functools.reduce f xs st
  foldl1 = f    xs -> functools.reduce f xs
  scanl  = f st xs -> itertools.accumulate (st:xs) f
  scanl1 = f    xs -> itertools.accumulate xs f
  # FIXME should also define foldr(1) and scanr(1). Probably.

  head = xs -> next $ iter xs
  fst  = xs -> next $ iter xs  # same as `head`, but with a different name
  snd  = xs -> head $ drop 1 xs
  tail = xs -> list $ drop 1 xs
  init = !! slice None -1
  last = !! -1

  otherwise = True
  finally   = True  # not actually used

  #: A version of __build_class__ that does not use functions.
  #:
  #: I bet you didn't even know __build_class__ existed.
  #:
  #: _ :: str (dict str object) (Maybe str: str str *type type **(dict str object) -> type
  #:
  __dg_build_class__ = module attrs doc qualname name *: bases metaclass: type **: kwds ->
    for q in bases => if
      issubclass metaclass (type q) => None
      issubclass (type q) metaclass => metaclass = type q
      otherwise => raise $ TypeError 'metaclass conflict'

    data = metaclass.__prepare__ name bases **: kwds
    data.update   attrs
    data.update $ dict __doc__: doc __qualname__: qualname __module__: module
    metaclass name bases data **: kwds
