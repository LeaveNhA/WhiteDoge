compile = x filename: '<string>' ->
  '''Compile some source code.

    x :: str (Optional str) -> CodeType

  '''
  compileast $ parse x filename


compilefd = x filename: '<stream>' ->
  '''Compile the contents of a file-like object.

    x :: TextIOBase (Optional str) -> CodeType

  '''
  compileast $ parsefd x filename


compileast = x ->
  '''Compile a pre-parsed AST.

    x :: Node -> CodeType

  '''
  gen = Generator '' False
  gen.load_ast x
  gen.add_opcode 'RETURN_VALUE'
  gen.frozen


ensure = f args min: 1 max: (float 'inf') ->
  '''Raise appropriate exceptions if the number of arguments
     is outside the specified range.

    ensure :: Name [a] int int -> [a]

  '''
  len args < min => Parser.error ('not enough arguments (got {}, min. {})'.format (len args) min) f.loc
  len args > max => Parser.error ('too many arguments (got {}, max. {})'  .format (len args) max) f.loc
  args


unpack = f args g ->
  '''Unpack function arguments by using another function as a template.

    unpack :: Name [Node] (T -> a) -> a

  '''
  except
    e =>
      a, kw, va, vkw = func_call_args args
      va or vkw => Parser.error "can't use varargs with compile-time macros" (va or vkw).loc
      g *: a **: kw
    e :: TypeError => Parser.error (str e) f.loc


Generator.load_const = x ~>
  '''Push `x` onto the value stack.

    Technically, `x` can be anything, but most types would make
    the code object unmarshallable.

    load_const :: object -> a

  '''
  @stackperm +1
  @add_opcode 'LOAD_CONST' $ @consts (x, type x)


Generator.load_ast = x ~>
  '''Push the result of evaluating `x` onto the value stack.

    load_ast :: Node -> a

  '''
  @lnomark x

  if x :: Name       => @load x.value
     x :: Constant   => @load_const x.value
     x :: LeftBind   => (@infixl !! x.op.value) self x.op *: x.args
     x :: RightBind  => (@infixr !! x.op.value) self x.op *: x.args
     x :: Expression => @load_call x.op *: x.args
     otherwise       => raise $ TypeError 'invalid node node' x (type x)


Generator.load_key = (k, v) ~>
  '''Push a string-object pair.

    load_key :: (str, Node) -> a

  '''
  @load_const k
  @load_ast   v


Generator.load_call = f *: args ~>
  '''Push the result of calling `f` with `args` onto the value stack.

    load_call :: Name (Many Node) -> a

  '''
  if f :: Name and f.value in @prefix => (@prefix !! f.value) self f args
     f.infix and not f.closed =>
       @load_ast f
       @call_infix_ast args
     otherwise =>
       @load_ast f
       @call_ast args 0


Generator.chain = *: (*xs, x) ~>
  '''Evaluate some expressions, return the result of the last one.

    chain :: Node (Many Node) -> a

  '''
  for y in xs =>
    @load_ast y
    @add_opcode 'POP_TOP'
    @currstack -= 1
  @load_ast x


Generator.store_ast = x ~>
  '''Store the value on top of the stack in a place referenced by an AST.

    store_ast :: Node -> a

  '''
  if
    x :: Expression and x.op == ',' =>
      # (a, b, c = x) => unpack `x` and call `store_ast` for each
      # of `a`, `b`, and `c`. If exactly of the items is preceded by a star
      # (e.g. `*c`), all items that didn't have place in other variables
      # are stored there as a list.
      star = -1

      for (i, q) in enumerate x.args => q :: RightBind and q.op == '*' =>
        star >= 0 => Parser.error 'only one starred item is allowed'    q.loc
        i > 255   => Parser.error 'too many items before a starred one' q.loc
        star = i
        x.args !! i = head q.args

      @stackperm $ len x.args - 1
      if star >= 0 => @add_opcode 'UNPACK_EX'       (256 * len x.args - 255 * star - 256)
         otherwise => @add_opcode 'UNPACK_SEQUENCE' (len x.args)

      exhaust $ map @store_ast x.args

    x :: RightBind and x.op == '@' =>
      # `@a` is equivalent to `self.a`.
      head x.args :: Name or Parser.error 'not an attribute' (head x.args).loc
      @load 'self'
      @add_opcode 'STORE_ATTR' $ @names (head x.args).value
      @currstack -= 2

    x :: Expression and len x.args == 2 and x.op == '.' =>
      # `a.b` => load `a`, store an attribute named `b`.
      snd x.args :: Name or Parser.error 'not an attribute' (snd x.args).loc
      @load_ast $ fst x.args
      @add_opcode 'STORE_ATTR' $ @names (snd x.args).value
      @currstack -= 2

    x :: Expression and len x.args == 2 and x.op == '!!' =>
      # `a !! b = x` <=> `a.__setitem__ b x`
      @load_ast $ fst x.args
      @load_ast $ snd x.args
      @add_opcode 'STORE_SUBSCR'
      @currstack -= 3

    x :: Name => @store x.value
    otherwise => Parser.error 'not something one can assign to' x.loc


Generator.infixl = collections.defaultdict (-> f a ~> @infixbind '<L>' '<R>' f a)
Generator.infixr = collections.defaultdict (-> f a ~> @infixbind '<R>' '<L>' f a)
Generator.prefix = dict'
  '',   f a ~> @load_call *: a
  '\n', f a ~> @chain     *: a
  '=',  f a ~>
    name, value = ensure f a 2 2
    @var, x = repr name, @var
    @load_ast value
    @var = x
    @stackperm +1
    @add_opcode 'DUP_TOP'
    @store_ast name

  '.',  f a ~>
    x, y = ensure f a 2 2
    y :: Name or Parser.error 'not an attribute' y.loc
    @load_ast x
    @add_opcode 'LOAD_ATTR' $ @names y.value
