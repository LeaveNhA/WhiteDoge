compile = x filename: '<string>' ->
  '''Compile some source code.

    x :: str (Optional str) -> CodeType

  '''
  compileast $ parse x filename


compilefd = x filename: '<stream>' ->
  '''Compile the contents of a file-like object.

    x :: TextIOBase (Optional str) -> CodeType

  '''
  compileast $ parsefd x filename


compileast = x ->
  '''Compile a pre-parsed AST.

    x :: Node -> CodeType

  '''
  gen = Generator '' True
  gen.load_ast x
  gen.add_opcode -1 'POP_TOP' 0
  # Since we're using cellvars/freevars for everything,
  # we need to sync the local namespace before finishing.
  gen.add_opcode +1 'LOAD_GLOBAL'   $ gen.names 'locals'
  gen.add_opcode -1 'CALL_FUNCTION' 0
  # Even modules got to return something.
  gen.load_const None
  gen.add_opcode -1 'RETURN_VALUE' 0
  gen.frozen


Generator.load_const = x ~>
  '''Push `x` onto the value stack.

    Technically, `x` can be anything, but most types would make
    the code object unmarshallable.

    load_const :: object -> a

  '''
  @add_opcode +1 'LOAD_CONST' $ @consts (x, type x)


Generator.load_ast = x ~>
  '''Push the result of evaluating `x` onto the value stack.

    load_ast :: Node -> a

  '''
  @lnomark x

  if x :: Name       => @load x
     x :: Constant   => @load_const x.value
     x :: LeftBind   => (@infixl !! x.op.value) self x.op *: x.args
     x :: RightBind  => (@infixr !! x.op.value) self x.op *: x.args
     x :: Expression => @load_call x.op *: x.args
     otherwise       => raise $ TypeError 'invalid node node' x (type x)


Generator.load_call = f *: args ~>
  '''Push the result of calling `f` with `args` onto the value stack.

    load_call :: Name (Many Node) -> a

  '''
  if f :: Name and f.value in @prefix => (@prefix !! f.value) self f args
     otherwise =>
       @load_ast f
       @call_ast args 0 (f.infix and not f.closed)


Generator.call_ast = args on_stack infix ~>
  '''Call a function on top of the stack.

    on_stack -- how many arguments are already `@load`ed.
    infix    -- whether to not parse keyword arguments.

    call_ast :: [Node] bool bool -> a

  '''
  # TODO parse args
  for a in args => @load_ast a
  @add_opcode (-len args - on_stack) 'CALL_FUNCTION' (len args + on_stack)


Generator.store_ast = x ~>
  '''Store the value on top of the stack in a place referenced by an AST.

    store_ast :: Node -> a

  '''
  raise NotImplementedError


Generator.infixl = dict!
Generator.infixr = dict!
Generator.prefix = dict' ('', s f a -> s.load_call *: a)
