compile = x filename: '<string>' ->
  '''Compile some source code.

    x :: str (Optional str) -> CodeType

  '''
  compileast $ parse x filename


compilefd = x filename: '<stream>' ->
  '''Compile the contents of a file-like object.

    x :: TextIOBase (Optional str) -> CodeType

  '''
  compileast $ parsefd x filename


compileast = x ->
  '''Compile a pre-parsed AST.

    x :: Node -> CodeType

  '''
  gen = Generator '' True
  gen.load_ast x
  gen.add_opcode -1 'RETURN_VALUE' 0
  gen.frozen


Generator.load_const = x ~>
  '''Push `x` onto the value stack.

    Technically, `x` can be anything, but most types would make
    the code object unmarshallable.

    load_const :: object -> a

  '''
  @add_opcode +1 'LOAD_CONST' $ @consts (x, type x)


Generator.load_ast = x ~>
  '''Push the result of evaluating `x` onto the value stack.

    load_ast :: Node -> a

  '''
  @lnomark x

  if x :: Name       => @load x
     x :: Constant   => @load_const x.value
     x :: LeftBind   => (@infixl !! x.op.value) self x.op *: x.args
     x :: RightBind  => (@infixr !! x.op.value) self x.op *: x.args
     x :: Expression => @load_call x.op *: x.args
     otherwise       => raise $ TypeError 'invalid node node' x (type x)


Generator.load_call = f *: args ~>
  '''Push the result of calling `f` with `args` onto the value stack.

    load_call :: Name (Many Node) -> a

  '''
  if f :: Name and f.value in @prefix => (@prefix !! f.value) self f args
     otherwise =>
       @load_ast f
       @call_ast args 0 (f.infix and not f.closed)


Generator.store_ast = x ~>
  '''Store the value on top of the stack in a place referenced by an AST.

    store_ast :: Node -> a

  '''
  raise NotImplementedError


# See `generator-closures` for default infix bind implementations.
Generator.infixl = collections.defaultdict (-> s f a -> s.infixbind '<L>' '<R>' f a)
Generator.infixr = collections.defaultdict (-> s f a -> s.infixbind '<R>' '<L>' f a)
Generator.prefix = dict' ('', s f a -> s.load_call *: a)
