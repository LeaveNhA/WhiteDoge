CO_OPTIMIZED = 1   # does not use slow locals
CO_NEWLOCALS = 2   # has a local namespace
CO_VARARGS   = 4   # accepts any amount of positional arguments
CO_VARKWARGS = 8   # accepts any amount of keyword arguments
CO_NESTED    = 16  # is a closure (unused, in fact)
CO_GENERATOR = 32  # uses YIELD_VALUE/YIELD_FROM
CO_NOFREE    = 64  # does not use cells

EXTENDED_ARG = dis.opmap.get 'EXTENDED_ARG'


codelen = seq ->
  '''Calculate the length of a bytecode sequence, in bytes.

    codelen :: [(int, int)] -> int

  '''
  sum $ map
    (c, v) -> if
      c < dis.HAVE_ARGUMENT => 1
      otherwise             => 3 * (1 + abs (v.bit_length! - 1) // 16)
    seq


OrderedSet = subclass dict where
  '''An ordered collection of unique non-removable elements.

    type OrderedSet a < dict a int

  '''
  __call__ = self k -> (self !! k = @get k $ len self)
  __iter__ = self   ->
    '''All items in this set, in insertion order.

      __iter__ :: iter a

    '''
    iter $ sorted @keys! key: @__getitem__


OrderedSetNegative = subclass OrderedSet where
  '''An ordered set that returns negative indices when called.'''
  __call__ = self k -> -1 - OrderedSet.__call__ self k


Generator = subclass object where
  '''A mutable version of `types.CodeType`.

    type Generator where
      cell     :: Maybe Generator -- a parent code object.
      argc     :: int
      kwargc   :: int
      name     :: str
      qualname :: str

      fastlocals :: dict set   -- maps names from `varnames` to opcode locations.
      varnames   :: tuple      -- a collection of (interned) argument names.
      names      :: OrderedSet -- attributes, slow locals, globals & modules
      consts     :: OrderedSet -- (type, value) pairs where value is constant
      freevars   :: OrderedSet -- non-local variables
      cellvars   :: OrderedSet -- local variables
      slowlocals :: bool -- whether to use `NAME` opcodes instead of `FAST` ones.
      enclosed   :: set  -- names that may be added to `freevars`.

      bytecode  :: [(int, int)] -- (opcode, argument) pairs.
      flags     :: int -- see the `CO_*` constants.
      stacksize :: int -- minimum stack depth required for evaluation.
      currstack :: int -- approx. stack depth at this point.

      filename :: str
      lineno   :: int
      lnotab   :: [int]
      lineoff  :: int -- `lineno` last time `lnotab` was updated.
      byteoff  :: int -- `len bytecode` at the same point.

  '''
  __init__ = name isfunc a: tuple! kw: tuple! va: tuple! vkw: tuple! cell: '' ~>
    @cell     = cell or None
    @argc     = len a
    @kwargc   = len kw
    @name     = name
    @qualname = ''.join $ list'
      cell => cell.qualname
      cell => cell.qualname => '.'
      cell => '<locals>.' * bool (cell.flags & CO_OPTIMIZED)
      name * bool isfunc

    @fastlocals = collections.defaultdict set
    @varnames   = OrderedSet $ zip (itertools.chain a kw va vkw) $ itertools.count 0
    @names      = OrderedSet!
    @consts     = OrderedSet!
    @cellvars   = OrderedSet!
    @freevars   = OrderedSetNegative!
    @slowlocals = not isfunc
    @enclosed   = if
      cell      => dict.keys cell.varnames | cell.cellvars | cell.enclosed
      otherwise => set!

    @bytecode = list!
    @flags    = foldl1 (|) $ list'
      CO_VARARGS   *  bool va
      CO_VARKWARGS *  bool vkw
      CO_NESTED    * (bool cell and not cell.slowlocals)
      CO_OPTIMIZED *  bool isfunc
      CO_NEWLOCALS *  bool isfunc

    # Set on first `lnomark`.
    @filename = '<generated>'
    @lineno   = 1
    @lnotab   = list!
    @lineoff  = -1
    @byteoff  = 0

    @stacksize = 0
    @currstack = 0
    None

  stackperm = x ~>
    '''Request a permanent increase in stack size.

      stackperm :: int -> ()

    '''
    # Python calculates the stack depth by scanning bytecode.
    # We'll opt for traversing the AST instead.
    @currstack += x
    @currstack > @stacksize => @stacksize = @currstack

  lnomark = x ~> if x.loc =>
    '''Add a location of a `Node` to the lnotab.

      lnomark :: Node -> a

    '''
    @lineoff < 0 =>
      @filename = x.loc !! 0
      @lineno   = x.loc !! 1
      @lineoff  = x.loc !! 1

    lineoff = x.loc !! 1 - @lineoff
    lineoff > 0 =>
      byteoff = codelen $ drop @byteoff @bytecode
      byteoff > 0 =>
        @lineoff = x.loc !! 1
        @byteoff = len @bytecode
        @lnotab += lineoff // 256 * b'\x00\xff'
        @lnotab += byteoff // 256 * b'\xff\x00'
        @lnotab += bytes (byteoff % 256, lineoff % 256)

  add_opcode = name value: 0 ~>
    '''Append a new opcode to the sequence.

      add_opcode :: str int int -> a

    '''
    @bytecode.append (dis.opmap !! name, value)

  frozen = ~>
    '''A marshallable code object with info from this generator.

      frozen :: CodeType

    '''
    types.CodeType @argc @kwargc (len @varnames) @stacksize
      @flags | (CO_NOFREE * not (@cellvars or @freevars))
      b''.join $ map @opcode @bytecode
      tuple $ map fst @consts
      tuple $ map sys.intern @names
      tuple $ map sys.intern @varnames
      @filename
      @name
      @lineno
      bytes @lnotab
      tuple $ map sys.intern @freevars
      tuple $ map sys.intern @cellvars

  opcode = (op, arg) ~>
    '''Generate a sequence of bytes for an opcode with an argument.

      opcode :: int int -> bytes

    '''
    arg < 0 => arg = len @cellvars - arg - 1

    if op < dis.HAVE_ARGUMENT => bytes $ list' op
       arg >= 0x10000 => @opcode EXTENDED_ARG (arg >> 16) + @opcode op (arg % 0x10000)
       otherwise      => bytes (op, arg % 0x100, arg >> 8)


if PY_TAG.startswith 'cpython-' =>
  # CPython-only optimization: call `PyCode_Optimize` before
  # freezing the code object.
  _optimize = (import '/ctypes/pythonapi').PyCode_Optimize
  _optimize.restype = import '/ctypes/py_object'
  _optimize.argtypes = list' py_object py_object py_object py_object

  Generator.frozen = ~>
    cd = _optimize (b''.join $ map @opcode @bytecode)
      cn = list  $ map fst        @consts
      nm = tuple $ map sys.intern @names
      ln = bytes @lnotab
    # Most of the functions are unaffected by the first run, but some
    # may benefit from two. PyCode_Optimize is pretty fast, so why not?
    cd = _optimize cd cn nm ln

    types.CodeType @argc @kwargc (len @varnames) @stacksize @flags cd
      tuple cn
      nm
      tuple $ map sys.intern @varnames
      @filename
      @name
      @lineno
      ln
      tuple $ map sys.intern @freevars
      tuple $ map sys.intern @cellvars
