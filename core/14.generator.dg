EXTENDED_ARG = dis.opmap.get 'EXTENDED_ARG'


codelen = seq ->
  '''Calculate the length of a bytecode sequence, in bytes.

    codelen :: [(int, int)] -> int

  '''
  sum $ map
    (c, v) -> if
      c < dis.HAVE_ARGUMENT => 1
      otherwise             => 3 * (1 + abs (v.bit_length! - 1) // 16)
    seq


OrderedSet = subclass dict where
  '''An ordered collection of unique non-removable elements.

    type OrderedSet a < dict a int

  '''
  __call__ = self k -> (self !! k = @get k $ len self)
  __iter__ = self   ->
    '''All items in this set, in insertion order.

      __iter__ :: iter a

    '''
    iter $ sorted @keys! key: @__getitem__


OrderedSetNegative = subclass OrderedSet where
  '''An ordered set that returns negative indices when called.'''
  __call__ = self k -> -1 - OrderedSet.__call__ self k


Generator = subclass object where
  '''A mutable version of `types.CodeType`.

    type Generator where
      cell      :: Maybe Generator -- a parent code object.
      argc      :: int
      kwargc    :: int
      varargs   :: bool -- accepts more than `argc` arguments.
      varkws    :: bool -- aceepts keyword arguments not in `varnames[argc:][:kwargc]`.
      function  :: bool -- is a function, not a module.
      generator :: bool -- is a function with `yield`.
      name      :: str
      qualname  :: str

      fastlocals :: dict set   -- maps names from `varnames` to opcode locations.
      consts     :: OrderedSet (object, type)
      varnames   :: OrderedSet str -- array-stored arguments.
      names      :: OrderedSet str -- attributes, globals & module names.
      cellvars   :: OrderedSet str -- local variables used by closures.
      freevars   :: OrderedSet str -- non-local variables.
      enclosed   :: set -- names that may be added to `freevars`.

      bytecode  :: [(int, int)] -- (opcode, argument) pairs.
      stacksize :: int -- minimum stack depth required for evaluation.
      currstack :: int -- approx. stack depth at this point.

      filename :: str
      lineno   :: int
      lnotab   :: bytes
      lineoff  :: int -- `lineno` last time `lnotab` was updated.
      byteoff  :: int -- `len bytecode` at the same point.

  '''
  __init__ = name function a: tuple! kw: tuple! va: tuple! vkw: tuple! cell: None ~>
    @cell      = cell
    @argc      = len a
    @kwargc    = len kw
    @varargs   = bool va
    @varkws    = bool vkw
    @function  = bool function
    @generator = False  # only becomes known during generation
    @name      = str name
    @qualname  = ''.join $ filter (x -> x) $ list'
      cell => cell.qualname
      cell => cell.qualname => '.'
      cell => cell.function => '<locals>.'
      function => name

    @fastlocals = collections.defaultdict set
    @consts     = OrderedSet!
    @varnames   = OrderedSet $ zip (itertools.chain a kw va vkw) $ itertools.count 0
    @names      = OrderedSet!
    @cellvars   = OrderedSet!
    @freevars   = OrderedSetNegative!
    @enclosed   = if
      cell      => dict.keys cell.varnames | cell.cellvars | cell.enclosed
      otherwise => set!

    @bytecode = list!
    @stacksize = 0
    @currstack = 0

    # Set on first `lnomark`.
    @filename = '<generated>'
    @lineno   = 1
    @lnotab   = b''
    @lineoff  = -1
    @byteoff  = 0
    None

  flags = ~>
    '''Calculated value of CodeType.co_flags.

      flags :: int

    '''
    foldl1 (|) $ filter (x -> x) $ list'
      @function  => 0b000011  # globals != locals & the latter are stored in an array
      @varargs   => 0b000100
      @varkws    => 0b001000
      @generator => 0b100000
      not @cellvars => not @freevars => 0b1000000

  stackperm = x ~>
    '''Request a permanent increase in stack size.

      stackperm :: int -> ()

    '''
    # Python calculates the stack depth by scanning bytecode.
    # We'll opt for traversing the AST instead.
    @currstack += x
    @currstack > @stacksize => @stacksize = @currstack

  lnomark = x ~> if x.loc =>
    '''Add a location of a `Node` to the lnotab.

      lnomark :: Node -> a

    '''
    @lineoff < 0 =>
      @filename = x.loc !! 0
      @lineno   = x.loc !! 1
      @lineoff  = x.loc !! 1

    lineoff = x.loc !! 1 - @lineoff
    lineoff > 0 =>
      byteoff = codelen $ drop @byteoff @bytecode
      byteoff > 0 =>
        @lineoff = x.loc !! 1
        @byteoff = len @bytecode
        @lnotab += lineoff // 256 * b'\x00\xff'
        @lnotab += byteoff // 256 * b'\xff\x00'
        @lnotab += bytes (byteoff % 256, lineoff % 256)

  add_opcode = name value: 0 ~>
    '''Append a new opcode to the sequence.

      add_opcode :: str int int -> a

    '''
    @bytecode.append (dis.opmap !! name, value)

  frozen = ~>
    '''A marshallable code object with info from this generator.

      frozen :: CodeType

    '''
    cd = b''.join $ map @opcode @bytecode
    cn =         map fst        @consts
    nm = tuple $ map sys.intern @names

    if @optimize =>
      cd = @optimize cd (cn = list cn) nm @lnotab
      # Most of the functions are unaffected by the first run, but some
      # may benefit from two.
      cd = @optimize cd cn nm @lnotab

    types.CodeType @argc @kwargc (len @varnames) @stacksize @flags cd (tuple cn) nm
      tuple $ map sys.intern @varnames
      @filename
      @name
      @lineno
      @lnotab
      tuple $ map sys.intern @freevars
      tuple $ map sys.intern @cellvars

  opcode = (op, arg) ~>
    '''Generate a sequence of bytes for an opcode with an argument.

      opcode :: int int -> bytes

    '''
    arg < 0 => arg = len @cellvars - arg - 1

    if op < dis.HAVE_ARGUMENT => bytes $ list' op
       arg >= 0x10000 => @opcode EXTENDED_ARG (arg >> 16) + @opcode op (arg % 0x10000)
       otherwise      => bytes (op, arg % 0x100, arg >> 8)

  optimize = if PY_TAG.startswith 'cpython-' => fn where
    import '/ctypes/pythonapi'
    import '/ctypes/py_object'
    fn = pythonapi.PyCode_Optimize
    fn.restype  = py_object
    fn.argtypes = py_object, py_object, py_object, py_object
