CO_OPTIMIZED = 1   # does not use slow locals
CO_NEWLOCALS = 2   # has a local namespace
CO_VARARGS   = 4   # accepts any amount of positional arguments
CO_VARKWARGS = 8   # accepts any amount of keyword arguments
CO_NESTED    = 16  # uses free variables
CO_GENERATOR = 32  # uses YIELD_VALUE/YIELD_FROM
CO_NOFREE    = 64  # does not export free variables

EXTENDED_ARG = dis.opmap.get 'EXTENDED_ARG'


opcode = (op, arg) ->
  '''Generate a sequence of bytes for an opcode with an argument.

    opcode :: int int -> bytes

  '''
  arg = int arg
  if op < dis.HAVE_ARGUMENT => bytes $ list' op
     arg >= 0x10000 => opcode EXTENDED_ARG (arg >> 16) + opcode op (arg % 0x10000)
     otherwise      => bytes (op, arg % 0x100, arg >> 8)


codelen = seq ->
  '''Calculate the length of a bytecode sequence, in bytes.

    codelen :: [(int, int)] -> int

  '''
  sum $ map
    (c, v) -> if c < dis.HAVE_ARGUMENT => 1
                 otherwise             => 3 * (1 + abs (int.bit_length (int v) - 1) // 16)
    seq


OrderedSet = subclass dict where
  '''An ordered collection of unique non-removable elements.

    type IndexedSet < dict

  '''
  __call__ = k ~>
    self !! k = @get k (len self)

  __iter__ = self ->
    '''All items in this set, in insertion order.

      contents :: [a]

    '''
    iter $ sorted @keys! key: @__getitem__


Generator = subclass object where
  '''A mutable version of `types.CodeType`.

    type Generator {
      cell     :: Maybe Generator -- a parent code object.
      name     :: str -- co_name
      qualname :: str -- __qualname__

      argc   :: int -- co_argcount
      kwargc :: int -- co_kwonlyargcount

      names    :: OrderedSet -- co_names  (attributes, slow locals, globals & modules)
      consts   :: OrderedSet -- co_consts ((type, value) pairs)
      freevars :: OrderedSet -- co_freevars (non-local variables)
      cellvars :: OrderedSet -- co_cellvars (local closure)
      varnames :: OrderedSet -- co_varnames (locally visible fast variables only)
      enclosed :: set -- names that may be added to `freevars`.

      slowlocals :: bool -- whether to not use _FAST opcodes.
      f_locals   :: {str: (int, int)} -- a cache to replace _FAST opcodes
                                      -- with _DEREF ones fast.

      bytecode :: [(int, int)] -- co_code as an unpacked list.
      flags    :: int          -- co_flags (see the `CO_*` constants.)

      filename :: str -- co_filename
      lineno   :: int -- co_firstlineno
      lnotab   :: [(int, int)] -- co_lnotab, unpacked.
      lineoff  :: int -- `lineno` last time `lnotab` was updated.
      byteoff  :: int -- `len bytecode` last time ...
    }

  '''
  __init__ = name isfunc a: tuple! kw: tuple! va: tuple! vkw: tuple! cell: '' ~>
    @name      = name
    @qualname  = ''.join $ list'
      cell => cell.qualname
      cell => cell.qualname => '.'
      cell => '<locals>.' * bool (cell.flags & CO_OPTIMIZED)
      name * bool isfunc

    @argc   = len a
    @kwargc = len kw

    @names    = OrderedSet!
    @consts   = OrderedSet!
    @freevars = OrderedSet!
    @cellvars = OrderedSet!
    @varnames = OrderedSet $ zip
      itertools.chain a kw va vkw  # attributes are stored as fast locals implicitly
      itertools.count 0

    @slowlocals = not isfunc
    @f_locals   = collections.defaultdict set

    @cell     = cell or None
    @enclosed = if
      # dg only uses slow locals in global namespaces and classes,
      # and the latter don't create new code objects.
      cell => dict.keys cell.varnames | cell.enclosed
      True => set!

    @bytecode = list!
    @flags  = CO_VARARGS   * bool va
    @flags |= CO_VARKWARGS * bool vkw
    @flags |= (CO_OPTIMIZED | CO_NEWLOCALS) * bool isfunc

    # Set on first `lnomark`.
    @filename = '<generated>'
    @lineno   = 1
    @lnotab   = list!
    @lineoff  = -1
    @byteoff  = 0

    @stacksize = 0
    @currstack = 0
    None

  stackperm = x ~>
    '''Request a permanent increase in stack size.

      stackperm :: int -> ()

    '''
    # Python calculates the stack depth by scanning bytecode.
    # We'll opt for traversing the AST instead.
    @currstack += x
    @currstack > @stacksize => @stacksize = @currstack

  lnomark = x ~> if x.loc =>
    '''Add a location of a `Node` to the lnotab.

      lnomark :: Node -> a

    '''
    @lineoff < 0 =>
      @filename = x.loc !! 0
      @lineno   = x.loc !! 1
      @lineoff  = x.loc !! 1

    lineoff = x.loc !! 1 - @lineoff
    lineoff > 0 =>
      byteoff = codelen $ drop @byteoff @bytecode
      byteoff > 0 =>
        @lineoff = x.loc !! 1
        @byteoff = len @bytecode
        @lnotab += lineoff // 256 * b'\x00\xff'
        @lnotab += byteoff // 256 * b'\xff\x00'
        @lnotab += bytes (byteoff % 256, lineoff % 256)

  add_opcode = name value: 0 ~>
    '''Append a new opcode to the sequence.

      add_opcode :: str int int -> a

    '''
    @bytecode.append (dis.opmap !! name, value)

  frozen = ~>
    '''A marshallable code object with info from this generator.

      frozen :: CodeType

    '''
    types.CodeType @argc @kwargc (len @varnames) @stacksize
      @flags | CO_NESTED * bool @freevars | CO_NOFREE * not @cellvars
      b''.join $ map opcode @bytecode
      tuple $ map fst @consts
      tuple @names
      tuple @varnames
      @filename
      @name
      @lineno
      bytes @lnotab
      tuple @freevars
      tuple @cellvars
