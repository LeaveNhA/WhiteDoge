CO_OPTIMIZED = 1   # does not use slow locals
CO_NEWLOCALS = 2   # has a local namespace
CO_VARARGS   = 4   # accepts any amount of positional arguments
CO_VARKWARGS = 8   # accepts any amount of keyword arguments
CO_NESTED    = 16  # is a closure (unused, in fact)
CO_GENERATOR = 32  # uses YIELD_VALUE/YIELD_FROM
CO_NOFREE    = 64  # does not use cells

EXTENDED_ARG = dis.opmap.get 'EXTENDED_ARG'


codelen = seq ->
  '''Calculate the length of a bytecode sequence, in bytes.

    codelen :: [(int, int)] -> int

  '''
  sum $ map
    (c, v) -> if c < dis.HAVE_ARGUMENT => 1
                 otherwise             => 3 * (1 + abs (v.bit_length! - 1) // 16)
    seq


OrderedSet = subclass dict where
  '''An ordered collection of unique non-removable elements.

    type IndexedSet < dict

  '''
  __call__ = self k -> (self !! k = @get k $ len self)
  __iter__ = self   ->
    '''All items in this set, in insertion order.

      contents :: [a]

    '''
    iter $ sorted @keys! key: @__getitem__


OrderedSetNegative = subclass OrderedSet where
  '''An ordered set that returns negative indices when called.'''
  __call__ = self k -> -1 - OrderedSet.__call__ self k


Generator = subclass object where
  '''A mutable version of `types.CodeType`.

    type Generator {
      cell     :: Maybe Generator -- a parent code object.
      name     :: str -- co_name
      qualname :: str -- __qualname__

      argc   :: int -- co_argcount
      kwargc :: int -- co_kwonlyargcount

      names      :: OrderedSet -- co_names  (attributes, slow locals, globals & modules)
      consts     :: OrderedSet -- co_consts ((type, value) pairs)
      freevars   :: OrderedSet -- co_freevars (non-local variables)
      cellvars   :: OrderedSet -- co_cellvars (local variables)
      enclosed   :: set -- names that may be added to `freevars`.
      slowlocals :: bool -- whether to use _NAME opcodes.

      bytecode :: [(int, int)] -- co_code as an unpacked list.
      flags    :: int          -- co_flags (see the `CO_*` constants.)

      filename :: str -- co_filename
      lineno   :: int -- co_firstlineno
      lnotab   :: [int] -- mutable co_lnotab
      lineoff  :: int -- `lineno` last time `lnotab` was updated.
      byteoff  :: int -- `len bytecode` last time ...
    }

  '''
  __init__ = name isfunc a: tuple! kw: tuple! va: tuple! vkw: tuple! cell: '' ~>
    @name      = name
    @qualname  = ''.join $ list'
      cell => cell.qualname
      cell => cell.qualname => '.'
      cell => '<locals>.' * bool (cell.flags & CO_OPTIMIZED)
      name * bool isfunc

    @argc   = len a
    @kwargc = len kw

    @_locals  = tuple $ map sys.intern $ itertools.chain a kw va vkw
    @names    = OrderedSet!
    @consts   = OrderedSet!
    @freevars = OrderedSetNegative!
    @cellvars = OrderedSet $ zip @_locals $ itertools.count 0

    @slowlocals = not isfunc
    @f_locals   = collections.defaultdict set

    @cell     = cell or None
    @enclosed = if
      # dg only uses slow locals in global namespaces and classes,
      # and the latter don't create new code objects.
      cell => dict.keys cell.cellvars | cell.enclosed
      True => set!

    @bytecode = list!
    @flags  = CO_VARARGS   * bool va
    @flags |= CO_VARKWARGS * bool vkw
    @flags |= CO_NESTED    * (bool cell and not cell.slowlocals)
    @flags |= (CO_OPTIMIZED | CO_NEWLOCALS) * bool isfunc

    # Set on first `lnomark`.
    @filename = '<generated>'
    @lineno   = 1
    @lnotab   = list!
    @lineoff  = -1
    @byteoff  = 0

    @stacksize = 0
    @currstack = 0
    None

  stackperm = x ~>
    '''Request a permanent increase in stack size.

      stackperm :: int -> ()

    '''
    # Python calculates the stack depth by scanning bytecode.
    # We'll opt for traversing the AST instead.
    @currstack += x
    @currstack > @stacksize => @stacksize = @currstack

  lnomark = x ~> if x.loc =>
    '''Add a location of a `Node` to the lnotab.

      lnomark :: Node -> a

    '''
    @lineoff < 0 =>
      @filename = x.loc !! 0
      @lineno   = x.loc !! 1
      @lineoff  = x.loc !! 1

    lineoff = x.loc !! 1 - @lineoff
    lineoff > 0 =>
      byteoff = codelen $ drop @byteoff @bytecode
      byteoff > 0 =>
        @lineoff = x.loc !! 1
        @byteoff = len @bytecode
        @lnotab += lineoff // 256 * b'\x00\xff'
        @lnotab += byteoff // 256 * b'\xff\x00'
        @lnotab += bytes (byteoff % 256, lineoff % 256)

  add_opcode = name value: 0 ~>
    '''Append a new opcode to the sequence.

      add_opcode :: str int int -> a

    '''
    @bytecode.append (dis.opmap !! name, value)

  frozen = ~>
    '''A marshallable code object with info from this generator.

      frozen :: CodeType

    '''
    types.CodeType @argc @kwargc (len @_locals) @stacksize @flags
      b''.join $ map @opcode @bytecode
      tuple $ map fst @consts
      tuple $ map sys.intern @names
      @_locals
      @filename
      @name
      @lineno
      bytes @lnotab
      tuple $ map sys.intern @freevars
      tuple $ map sys.intern @cellvars

  opcode = (op, arg) ~>
    '''Generate a sequence of bytes for an opcode with an argument.

      opcode :: int int -> bytes

    '''
    arg < 0 => arg = len @cellvars - arg - 1

    if op < dis.HAVE_ARGUMENT => bytes $ list' op
       arg >= 0x10000 => @opcode EXTENDED_ARG (arg >> 16) + @opcode op (arg % 0x10000)
       otherwise      => bytes (op, arg % 0x100, arg >> 8)


if PY_TAG.startswith 'cpython-' =>
  # CPython-only optimization: call `PyCode_Optimize` before
  # freezing the code object.
  _optimize = (import '/ctypes/pythonapi').PyCode_Optimize
  _optimize.restype = import '/ctypes/py_object'
  _optimize.argtypes = list' py_object py_object py_object py_object

  Generator.frozen = ~>
    cd = _optimize (b''.join $ map @opcode @bytecode)
      cn = list  $ map fst        @consts
      nm = tuple $ map sys.intern @names
      ln = bytes @lnotab
    # Most of the functions are unaffected by the first run, but some
    # may benefit from two. PyCode_Optimize is pretty fast, so why not?
    cd = _optimize cd cn nm ln

    types.CodeType @argc @kwargc (len @_locals) @stacksize @flags cd
      tuple cn
      nm
      @_locals
      @filename
      @name
      @lineno
      ln
      tuple $ map sys.intern @freevars
      tuple $ map sys.intern @cellvars
