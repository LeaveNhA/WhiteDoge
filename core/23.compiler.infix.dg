COMPARISON   = set' '<' '<=' '!=' '==' '>=' '>' 'is' 'in'
COMPARISON_H = f (a, b) chain: False ~>
  # `a R b Q c` <=> `a R b and b Q c` for any given comparison
  # operators R and Q. (`b` is only evaluated once.)
  double = a :: Expression and not a.closed and a.op.value in COMPARISON
  jumps  = if double    => (ARGCOUNT 2 $ bind COMPARISON_H chain: True) self a.op a.args
              otherwise => list! where @pushast a

  if
    chain => jumps.append $
      @pushast b
      @append  'DUP_TOP'    delta: +1 #=> a, b, b
      @append  'ROT_THREE'  delta: +0 #=> b, a, b
      @append  'COMPARE_OP' delta: -1 $ dis.cmp_op.index f.value
      @jump    'JUMP_OR_POP_IF_FALSE' delta: -1 #=> b if OK; b, False otherwise.

    otherwise =>
      @pushast b #=> a, b
      @append  'COMPARE_OP' delta: -1 $ dis.cmp_op.index f.value
      # Now, what if one of the comparisons returned False?
      # First, we jump here.
      jumps => with @jump 'JUMP_FORWARD' =>
        for j in jumps => j.set
        # Then we remove the unneeded item, leaving `False` on the stack.
        # (Stack size change was already accounted for by JUMP_IF_FALSE_OR_POP.)
        @append 'ROT_TWO'
        @append 'POP_TOP'

  # Return the list of unfinished jumps for the next operator to use.
  jumps

for c in COMPARISON => Compiler.prefix !! c = ARGCOUNT 2 COMPARISON_H


### Part 5. Unsorted.

if_syntax = cases -> except
  e => list $ map
    x -> if
      x :: Expression and x.op == '=>' and len x.args == 2 => x.args
      otherwise => ERROR x '`if` expected (condition => action) pairs'
    cases
  e :: SyntaxError and len cases == 1 and head cases :: Expression and (head cases).op == '' =>
    if_syntax $ (head cases).args


Compiler.prefix !! 'if' = f xs ~>
  jumps = list
    where for (cond, action) in if_syntax xs =>
      @pushast cond
      with @jump 'POP_JUMP_IF_FALSE' delta: -1 =>
        @pushast action
        yield $ @jump 'JUMP_FORWARD' delta: -1
  @pushconst None
  for x in jumps => x.set
