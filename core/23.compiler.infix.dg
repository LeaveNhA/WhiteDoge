Generator.infix_unary = op x ~>
  @load_ast x
  @add_opcode op 0 0


Generator.infix_binary = op f args ~>
  x, y = ensure f args 2 2
  @load_ast x
  @load_ast y
  @add_opcode op -1 0
  x

Generator.infix_inplace = op f args ~>
  q = @infix_binary op f args
  @add_opcode 'DUP_TOP' +1 0
  @store_ast q


jump = x -> f args ~>
  a, b = ensure f args 2 2
  @load_ast a
  jmp = @jump_or_pop_if x reverse: False
  @depth -= 1
  @load_ast b
  jmp.set


comparison = op -> f args chain: False ~>
  a, b = ensure f args 2 2

  double = a :: Expression and not a.closed and a.op.value in @prefix and
    f = @prefix !! a.op.value
    getattr f '__code__' None is comparison.__code__.co_consts !! 0

  # Now `double` is true iff `a` is another comparison.
  # Also, `e`, `ex`, and `f` will be defined if that is the case.
  jumps = if (double => f self a.op a.args chain: True) (otherwise => list!)

  # If not, then `a` is a plain old boring expression.
  not double => @load_ast a

  if
    chain => jumps.append $
      @load_ast b
      @add_opcode 'DUP_TOP'    +2 0  # [a, b]
      @add_opcode 'ROT_THREE'  +0 0  # [b, a, b]
      @add_opcode 'COMPARE_OP' -1 $ dis.cmp_op.index op  # [b, a R b]
      @depth -= 1
      @jump_or_pop_if False reverse: False

    otherwise =>
      @load_ast b
      @add_opcode 'COMPARE_OP' -1 $ dis.cmp_op.index op  # [a R b]
      # Now, what if one of the comparisons returned False?
      # First, we jump here.
      jumps =>
        ontrue = @jump reverse: False
        for j in jumps => j.set
        # Then we remove the unneeded item, leaving `False` on the stack.
        # (Stack size change was already accounted for by JUMP_IF_FALSE_OR_POP.)
        @add_opcode 'ROT_TWO' 0 0  # [False, b]
        @add_opcode 'POP_TOP' 0 0  # [False]
        ontrue.set

  # Return the list of unfinished jumps for the next operator to use.
  jumps


if_syntax = cases -> except
  e => list $ map
    x -> if
      x :: Expression and x.op == '=>' and len x.args == 2 => x.args
      otherwise => Parser.error '`if` expected (condition => action) pairs' x.loc
    cases
  e :: SyntaxError and len cases == 1 and head cases :: Expression and (head cases).op == '' =>
    if_syntax $ (head cases).args


Generator.infixl.update $ dict'
  '!', f q ~> @load_call q
  '~', f q ~> Parser.error 'this operator is prefix' f.loc
  '@', f q ~> Parser.error 'this operator is prefix' f.loc

Generator.infixr.update $ dict'
  '!', f q ~> Parser.error 'this operator is postfix' f.loc
  '~', f q ~> @infix_unary 'UNARY_INVERT'   q
  '-', f q ~> @infix_unary 'UNARY_NEGATIVE' q
  '@', f q ~> (Generator.prefix !! '.') self f (Name 'self' at: f.loc, q)

Generator.prefix.update $ dict'
  'or',  jump True
  '=>',  jump False
  'and', jump False
  'not', f q ~> @infix_unary 'UNARY_NOT' $ head $ ensure f q 1 1
  '!',   f q ~> Parser.error 'this operator is unary' f.loc
  '~',   f q ~> Parser.error 'this operator is unary' f.loc
  '@',   f q ~> Parser.error 'this operator is unary' f.loc
  '!!',  f q ~> @infix_binary  'BINARY_SUBSCR'        f q
  '+',   f q ~> @infix_binary  'BINARY_ADD'           f q
  '-',   f q ~> @infix_binary  'BINARY_SUBTRACT'      f q
  '*',   f q ~> @infix_binary  'BINARY_MULTIPLY'      f q
  '**',  f q ~> @infix_binary  'BINARY_POWER'         f q
  '/',   f q ~> @infix_binary  'BINARY_TRUE_DIVIDE'   f q
  '//',  f q ~> @infix_binary  'BINARY_FLOOR_DIVIDE'  f q
  '%',   f q ~> @infix_binary  'BINARY_MODULO'        f q
  '&',   f q ~> @infix_binary  'BINARY_AND'           f q
  '^',   f q ~> @infix_binary  'BINARY_XOR'           f q
  '|',   f q ~> @infix_binary  'BINARY_OR'            f q
  '<<',  f q ~> @infix_binary  'BINARY_LSHIFT'        f q
  '>>',  f q ~> @infix_binary  'BINARY_RSHIFT'        f q
  '!!=', f q ~> @infix_inplace 'BINARY_SUBSCR'        f q
  '+=',  f q ~> @infix_inplace 'INPLACE_ADD'          f q
  '-=',  f q ~> @infix_inplace 'INPLACE_SUBTRACT'     f q
  '*=',  f q ~> @infix_inplace 'INPLACE_MULTIPLY'     f q
  '**=', f q ~> @infix_inplace 'INPLACE_POWER'        f q
  '/=',  f q ~> @infix_inplace 'INPLACE_TRUE_DIVIDE'  f q
  '//=', f q ~> @infix_inplace 'INPLACE_FLOOR_DIVIDE' f q
  '%=',  f q ~> @infix_inplace 'INPLACE_MODULO'       f q
  '&=',  f q ~> @infix_inplace 'INPLACE_AND'          f q
  '^=',  f q ~> @infix_inplace 'INPLACE_XOR'          f q
  '|=',  f q ~> @infix_inplace 'INPLACE_OR'           f q
  '<<=', f q ~> @infix_inplace 'INPLACE_LSHIFT'       f q
  '>>=', f q ~> @infix_inplace 'INPLACE_RSHIFT'       f q
  '<',  comparison '<'
  '<=', comparison '<='
  '==', comparison '=='
  '!=', comparison '!='
  '>',  comparison '>'
  '>=', comparison '>='
  'is', comparison 'is'
  'in', comparison 'in'

  'if', f q ~>
    jumps = list $ map
      (cond, action) ->
        @load_ast cond
        next = @pop_jump_if False reverse: False
        @depth -= 1
        @load_ast action
        end = @jump reverse: False
        @depth -= 1
        next.set
        end
      if_syntax q

    @load_const None
    for x in jumps => x.set


  ',', f xs ~>
    exhaust $ map @load_ast xs
    @add_opcode 'BUILD_TUPLE' +1 (len xs)

  '$', f xs ~>
    a, b = ensure f xs 2 2
    if a :: Expression and not a.closed and a.op == '' => @load_call a.op *: (a.args + list' b)
       otherwise => @load_call a b

  '!!~', f x ~>
    @infix_binary 'DELETE_SUBSCR' f x
    @depth -= 1
    @load_const None

  '.~', f q ~>
    a, b = ensure f q 2 2
    b :: Name or Parser.error 'not an attribute' b.loc
    @load_const None
    @load_ast   a
    @add_opcode 'DELETE_ATTR' -1 $ @names b.value

  '!.', f q ->
    a, b = ensure f q 2 2
    b :: Name or Parser.error 'not an attribute' b.loc
    @load_call  a
    @add_opcode 'LOAD_ATTR' 0 $ @names b.value
