import '/sys'
import '/runpy'
import '/argparse'
import '/importlib'

import '/dg'
import '/dg/core'
import '/dg/addon/repl'


p = argparse.ArgumentParser formatter_class: argparse.RawDescriptionHelpFormatter add_help: False
  prog:   'python -m dg'
  usage:  '%(prog)s [-q] [-X module ...] [-h | -b | -c command | -m module | file] ...'
  epilog: '''

Options and arguments:

  -h           show this message and exit
  -b           rebootstrap the compiler
  -q           enable awesome tracebacks and prompts (equivalent to -X dg.addon.awful)
  -X module    enable compile-time macros from a specific module
  -c command   run a single command, then exit
  -m module    run a module (or a package's `__main__`) as a script
  file         run a script
  ...          additional arguments accessible through `sys.argv`

Environment variables:

  PYTHONSTARTUP     a Python file executed on interactive startup
  PYTHONSTARTUPDG   same as PYTHONSTARTUP, only in dg

'''

g = p.add_mutually_exclusive_group required: False
g.add_argument '-h'   help: argparse.SUPPRESS dest: 'help'    action: 'store_true'
g.add_argument '-b'   help: argparse.SUPPRESS dest: 'build'   action: 'store_true'
g.add_argument '-c'   help: argparse.SUPPRESS dest: 'command'
g.add_argument '-m'   help: argparse.SUPPRESS dest: 'module'
p.add_argument '-q'   help: argparse.SUPPRESS dest: 'extend'  action: 'append_const' const: 'dg.addon.awful'
p.add_argument '-X'   help: argparse.SUPPRESS dest: 'extend'  action: 'append'
p.add_argument 'args' help: argparse.SUPPRESS nargs: argparse.REMAINDER
ns = p.parse_args!

for e in (ns.extend or ()) => dg.Compiler.extend $ importlib.import_module $ e + '-macro'
if
  ns.help  => p.print_help!
  ns.build =>
    print $ 'Target: {0} 0x{1:X}'.format dg.PY_TAG dg.PY_VERSION
    this = core.load dg.PY_TAG dg.BUNDLE_DIR

    # Ideally, three iterations should be enough:
    #   1. Make a bundle with new features.
    #   2. Recompile it to apply these features to the compiler itself.
    #   3. Check that the compiler can still support itself.
    for i in range 1 4 =>
      print 'Iteration:' i
      that = list $ core.build this dg.PY_TAG dg.PY_VERSION
      diff = that != this
      this = that

    if diff =>
      print $ 'FATAL: Differences found during the last iteration.'
      print $ 'FATAL: A compiler error was detected. Aborting.'
      exit 1

    core.save this dg.PY_TAG dg.BUNDLE_DIR
    exit 0

  ns.command => repl.runcode $ dg.compile ns.command       where sys.argv = list ('-c':+ns.args)
  ns.module  => runpy.run_module alter_sys: True ns.module where sys.argv = list ('-m':+ns.args)
  otherwise  =>
    sys.argv = ns.args
    filedesc = if ns.args   => open encoding: 'utf-8' errors: 'strict' $ head ns.args
                  otherwise => sys.stdin
    if filedesc.isatty! => repl.runrepl filedesc startup: (filedesc is sys.stdin)
       otherwise        => repl.runcode $ dg.compilefd filedesc filedesc.name
