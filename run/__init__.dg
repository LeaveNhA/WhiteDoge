import '/os'
import '/sys'
import '/builtins'

import '../compile'
import '../parse'


complete = code -> unsafe
  e =
    expr = res = parse.it code '<stdin>'

    # Search for incomplete infix expressions.
    while (expr :: parse.tree.Expression and not expr.closed) (expr !!= -1)

    res if code.endswith '\n' or not
      (code.rsplit '\n' 1 !! -1).startswith ' ' or
        expr :: parse.tree.Link and not expr.closed and expr in compile.r.builtins or
          expr :: parse.tree.Expression and len expr == 2

  e :: SyntaxError and (e.args !! 0).startswith 'unexpected EOF' = None


# Start an interactive shell.
#
# :param name: name of the module.
#
# :return: runs indefinitely.
#
it = (fd __name__: '__main__') ->
  environ  = dict __name__: __name__ __builtins__: __builtins__

  fd.isatty! or unsafe
    e = eval (compile.it $ parse.it filename: fd.name $ fd.read -1) environ, exit 0
    e and not (e :: SystemExit) = sys.excepthook (type e) e e.__traceback__.tb_next, exit 1

  fd is sys.stdin and
    st = os.environ.get 'PYTHONSTARTUP' ''
    eval (builtins.compile ((open st).read -1) st 'exec') environ if st

  sys.ps1 = getattr sys 'ps1' '>>> '
  sys.ps2 = getattr sys 'ps2' '... '
  sys.stdin = fd

  while True $ unsafe
    e =
      buf = input sys.ps1
      while (not (y = complete buf)) (buf += '\n' + input sys.ps2)
      sys.displayhook $ eval (compile.it y) environ
    e :: EOFError = print!, exit 0
    e :: SystemExit = raise e
    e = sys.excepthook (type e) e e.__traceback__.tb_next
