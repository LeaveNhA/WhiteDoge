os       = new import
sys      = new import
builtins = new import

..parse   = new import
..compile = new import


complete = (parser, compiler, code) -> unsafe
  e =
    expr = res = parser.parse code '<stdin>'

    # Search for incomplete infix expressions.
    while (expr :: parse.tree.Expression and not expr.closed and len expr > 2) (expr !!= -1)

    res if code.endswith '\n' or not
      (code.rsplit '\n' 1 !! -1).startswith ' ' or
        expr :: parse.tree.Link and not expr.closed and expr in compiler.builtins or
          expr :: parse.tree.Expression and not expr.closed

  e :: SyntaxError and e.args !! 0 in ('mismatched parentheses', 'mismatched quote') = None


# Start an interactive shell.
#
# :param name: name of the module.
#
# :return: runs indefinitely.
#
dg = (fd, __name__: '__main__') ->
  parser   = new parse.r
  compiler = new compile.r
  environ  = dict __name__: __name__ __builtins__: __builtins__

  call fd.isatty or unsafe
    e = eval (compiler.compile $ parser.parse filename: fd.name $ fd.read -1) environ, exit 0
    e and not (e :: SystemExit) = sys.excepthook (type e) e e.__traceback__.tb_next, exit 1

  fd is sys.stdin and
    st = os.environ.get 'PYTHONSTARTUP' ''
    eval (builtins.compile ((open st).read -1) st 'exec') environ if st

  sys.ps1 = getattr sys 'ps1' '>>> '
  sys.ps2 = getattr sys 'ps2' '... '
  sys.stdin = fd

  while True $ unsafe
    e =
      buf = input sys.ps1
      while (not (y = complete parser compiler buf)) (buf += '\n' + input sys.ps2)
      sys.displayhook $ eval (compiler.compile y) environ
    e :: EOFError = call print, exit 0
    e :: SystemExit = raise e
    e = sys.excepthook (type e) e e.__traceback__.tb_next
