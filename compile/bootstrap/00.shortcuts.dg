builtins  = new import
operator  = new import
functools = new import
itertools = new import
importlib = new import

# Choose a function based on the number of arguments.
varary = (*fs) -> (*xs) -> (fs !! (len xs > 1)) (*): xs

# Reduce a varary left-fixed operator to a binary one.
reduce = f -> (a, *xs) -> foldl f xs a


builtins.new  = builtins.call = builtins.($) = (f, *xs) -> f (*): xs
builtins.(,)  = (*xs) -> xs

builtins.(<)  = reduce operator.lt
builtins.(<=) = reduce operator.le
builtins.(==) = reduce operator.eq
builtins.(!=) = reduce operator.ne
builtins.(>)  = reduce operator.gt
builtins.(>=) = reduce operator.ge
builtins.(is) = reduce operator.is_
builtins.(in) = reduce (a, b) -> (operator.contains b a)

builtins.not  = reduce operator.not_
builtins.(~)  = reduce operator.invert
builtins.(+)  = varary operator.pos (reduce operator.add)
builtins.(-)  = varary operator.neg (reduce operator.sub)
builtins.(*)  = reduce operator.mul
builtins.(**) = reduce operator.pow
builtins.(/)  = reduce operator.truediv
builtins.(//) = reduce operator.floordiv
builtins.(%)  = reduce operator.mod
builtins.(!!) = reduce operator.getitem
builtins.(!@) = (a, *xs) -> (!!) a (*): (itertools.starmap slice xs)
builtins.(&)  = reduce operator.and_
builtins.(^)  = reduce operator.xor
builtins.(|)  = reduce operator.or_
builtins.(<<) = reduce operator.lshift
builtins.(>>) = reduce operator.rshift

builtins.import = importlib.import_module
builtins.bind   = functools.partial
builtins.foldl  = functools.reduce
# FIXME should also define foldr (and scanl (and scanr, lol.))
# Not-actually-operators.
builtins.(...)  = Ellipsis
builtins.(..)   = range
builtins.(::)   = (a, *xs) -> a `isinstance` xs
