unsafe_s = cases ->
  pairs = list $ map
    bind syntax.binary_op '=' on_error:
      bind syntax.error '`unsafe` requires `condition = action` pairs'
    cases

  pairs, (pairs.pop! if len pairs > 1 and pairs !! -1 !! 0 == 'True' else (None, None))


#
# raise exception [[caused_by:] cause]
#
# Raise an exception with a given cause (or None).
# (See Python documentation if you don't know what a cause is.)
#
PREFIX !! 'raise' = (self f args) ->
  args = unpack f args (exception caused_by: None) -> (tuple' exception if caused_by is None else exception, caused_by)
  self.loadop 'RAISE_VARARGS' *: args delta: 0
  self.load   None  # We've got to return something.


#
# unsafe
#   error = expression
#   condition = when_condition_is_True
#   ...
#   True = cleanup
#
# 1. Evaluate `expression`.
# 2. Store either the exception or `None` in `error`.
# 3. Do the same thing as `switch` with the rest of the arguments...
# 3.1. ...except the last one, if it has a condition of `True`.
# 3.2. If it does, evaluate it regardless, but don't allow it to silence the exception.
#
# Returns `expression` if it was successful, `None` otherwise.
#
PREFIX !! 'unsafe' = (self f cases) ->
  # http://i2.kym-cdn.com/photos/images/original/000/234/765/b7e.jpg
  # That seems to work, though.
  ((name, try), *cases), (has_finally, finally) = unsafe_s $ ensure f cases

  # This will be our return value.
  self.load None

  to_finally = self.loadop 'SETUP_FINALLY' delta: 0 if has_finally
  to_except  = self.loadop 'SETUP_EXCEPT'  delta: 0
  # Replace that None with the value returned by `try_`
  # to fool the POP_BLOCK instruction.
  self.loadop 'ROT_TWO' try delta:  1
  self.loadop 'POP_BLOCK'   delta: -1
  # Er, so there was no exception, let's store None instead.
  # Since we've already POPped_BLOCK, exceptions occured
  # during this assignment won't be caught.
  self.store name None

  # Jump over that block if there was no exception.
  # Finishing SETUP_EXCEPT with an exception pushes
  # 3 items onto the stack.
  #
  # Stack:: [try, None] or [None, traceback, value, type]
  #
  to_else = self.loadop 'JUMP_FORWARD' delta: 2  # one is on the stack already
  to_except!
  self.loadop 'ROT_TWO' delta: 0
  self.loadop 'DUP_TOP' delta: 1
  self.store_top name
  self.loadop 'ROT_TWO' delta: 0
  to_else!

  # The `switch` statement.
  # XXX is that considered "code duplication"?
  jumps = list $ map (cond, action) -> (
    next = self.loadop 'POP_JUMP_IF_FALSE' cond delta: 0
    end  = self.loadop 'JUMP_FORWARD'    action delta: 0
    next!
    end
  ) cases

  # This will re-raise the exception if nothing matched
  # (and there was an exception. And there is no `finally` clause.)
  self.loadop 'END_FINALLY' delta: -3

  # The problem is, now we need to POP_EXCEPT, but only
  # if there was a handled exception.

  # First, jump over this whole part if the exception was not handled.
  unhandled_exception = self.loadop 'JUMP_FORWARD' delta: 0

  # Second, check if the exception type is None, in which case
  # there was no exception at all.
  list $ map call jumps
  self.loadop 'POP_TOP' delta: 0  # that was pushed by a handler
  self.loadop 'DUP_TOP' delta: 1
  self.loadop 'COMPARE_OP' None arg: 'is' delta: 0
  # Then skip POP_EXCEPT if that is the case.
  no_exception = self.loadop 'POP_JUMP_IF_TRUE' delta: -1

  self.loadop 'POP_EXCEPT' delta: 0
  unhandled_exception!
  no_exception!

  has_finally and
    # If the interpreter made it here, one of the `except` clauses matched.
    self.loadop 'POP_BLOCK' delta: -1
    self.load   None

    to_finally!
    self.loadop 'POP_TOP' finally delta: 0
    self.loadop 'END_FINALLY'     delta: 0

  # We should be left with a return value by now.
