..compile    = import:
..parse.tree = import:


# Translate `a R b Q c` into `(a R b) and (b Q c)`
# iff both `R` and `Q` are comparison operators, but without
# evaluating `b` twice.
#
# Examples::
#
#   >>> varary_cmp: '<' compiler a b
#     1 LOAD       a
#     2 LOAD       b
#     3 COMPARE_OP <
#
#   >>> varary_cmp: '<' compiler a b c
#     1 LOAD                      a
#     2 LOAD                      b
#     3 DUP_TOP
#     4 ROT_THREE
#     5 COMPARE_OP                <
#     6 JUMP_IF_FALSE_ELSE_POP   10
#     7 LOAD                      c
#     8 COMPARE_OP                <
#     9 JUMP_FORWARD              2 (to 12)
#  > 10 ROT_TWO
#    11 POP_TOP
#  > 12 <out of scope of this function>
#
# (Yes, Python compiler generates the same bytecode.)
#
varary_cmp = (operator, self, a, *bs, chained: False) ->
  # The last argument is a special case unless we want
  # to insert a jump opcode afterwards.
  *bs, c = bs unless chained

  a_is_cmpop = a :: parse.tree.Expression and not: a.closed and
    e, *ex = a
    e :: parse.tree.Link and e `in` compile.r.builtins and
      f = compile.r.builtins !! e
      f :: (~:) and f.func `is` varary_cmp

  # If `a` is not a comparison (or is closed), simply load it.
  self.load: a unless a_is_cmpop
  jmps = list:                     unless a_is_cmpop
  # Otherwise, call `varary_op` with `chained` set to True.
  jmps = f: self chained: True (*): ex if a_is_cmpop
  jmps = jmps +
    list:
      map: b -> (
        self.opcode: 'DUP_TOP' b delta: 2
        self.opcode: 'ROT_THREE' delta: 0
        self.opcode: 'COMPARE_OP' arg: operator delta: -1
        self.opcode: 'JUMP_IF_FALSE_OR_POP' delta: -1
      ) bs

  chained or
    self.load: c
    self.opcode: 'COMPARE_OP' arg: operator delta: -1

    jmps and
      jmp = self.opcode: 'JUMP_FORWARD' delta: 0
      list: (map: (:) jmps)
      # Exceptional case: one of the comparisons returned False.
      self.opcode: 'ROT_TWO' delta: 0
      self.opcode: 'POP_TOP' delta: 0  # that -1 was accounted for by JUMP_IF_FALSE_OR_POP
      jmp:

  jmps


compile.r.builtins !! '<'   = varary_cmp ~: '<'
compile.r.builtins !! '<='  = varary_cmp ~: '<='
compile.r.builtins !! '=='  = varary_cmp ~: '=='
compile.r.builtins !! '!='  = varary_cmp ~: '!='
compile.r.builtins !! '>'   = varary_cmp ~: '>'
compile.r.builtins !! '>='  = varary_cmp ~: '>='
compile.r.builtins !! 'is'  = varary_cmp ~: 'is'
compile.r.builtins !! 'in'  = varary_cmp ~: 'in'
