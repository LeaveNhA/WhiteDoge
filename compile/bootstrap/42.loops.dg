import '/itertools/chain'
import '/itertools/repeat'
import '/itertools/product'


# while condition => body
#
# Evaluate the body while condition is true.
#
PREFIX !! 'while' = (self f args) ->
  cond, *body = ensure f args

  self.load None  # This will be the value returned by the last iteration.
  to_cond = self.loadop 'JUMP_FORWARD'             delta:  0
  to_body = self.loadop 'POP_JUMP_IF_TRUE' arg: -1 delta: -1  # delta = ???
  if (body => self.chain *: body) (otherwise => self.load None)
  self.loadop 'ROT_TWO' delta:  0
  self.loadop 'POP_TOP' delta: -1
  to_cond!
  self.load cond
  to_body!


# for variable in iterable => body
#
# ???
#
PREFIX !! 'for' = (self f args) ->
  condition, body = ensure f args 2 2
  k, v = for' condition

  self.load None
  self.loadop 'GET_ITER' v delta: 1
  loop = self.loadop 'JUMP_ABSOLUTE' delta: 0 arg: -1
  end  = self.loadop 'FOR_ITER'      delta: 1
  self.store_top k
  self.loadop 'POP_TOP' body delta: -1
  loop!
  end!


for' = x -> if x :: parse.Expression and fst x == 'in' => tail x
               otherwise => syntax.error 'not an allowed construct' x
