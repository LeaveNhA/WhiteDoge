except_syntax = cases ->
  pairs = if_syntax cases
  pairs, if len pairs > 1 and head (last pairs) == 'finally' => pairs.pop!
            otherwise => None, None


#
# raise exception [[cause:] another_exception]
#
# Raise an exception with a given cause (or None).
# (See Python documentation if you don't know what a cause is.)
#
PREFIX !! 'raise' = self f args ->
  args = unpack f args $ exception cause: None ->
    if cause is None => tuple' exception
       otherwise     => exception, cause
  self.loadop 'RAISE_VARARGS' *: args delta: 0
  self.load   None  # We've got to return something.


#
# except
#   error => expression
#   condition => when_condition_is_True
#   ...
#   finally => cleanup
#
# 1. Evaluate `expression`.
# 2. Store either the exception or `None` in `error`.
# 3. Do the same thing as `switch` with the rest of the arguments...
# 3.1. ...except the last one, if it has a condition of `True`.
# 3.2. If it does, evaluate it regardless, but don't allow it to silence the exception.
#
# Returns `expression` if it was successful, `None` otherwise.
#
PREFIX !! 'except' = self f cases ->
  # http://i2.kym-cdn.com/photos/images/original/000/234/765/b7e.jpg
  # That seems to work, though.
  ((name, try), *cases), (has_finally, finally) = except_syntax $ ensure f cases

  # This will be our return value.
  self.load None

  to_finally = has_finally and self.loadop 'SETUP_FINALLY' delta: 0
  to_except  = self.loadop 'SETUP_EXCEPT'  delta: 0
  # Replace that None with the value returned by `try_`
  # to fool the POP_BLOCK instruction.
  self.loadop 'ROT_TWO' try delta:  1
  self.loadop 'POP_BLOCK'   delta: -1
  # Er, so there was no exception, let's store None instead.
  # Since we've already POPped_BLOCK, exceptions occured
  # during this assignment won't be caught.
  self.store name None

  # Jump over that block if there was no exception.
  # Finishing SETUP_EXCEPT with an exception pushes
  # 3 items onto the stack.
  #
  # Stack:: [try, None] or [None, traceback, value, type]
  #
  to_else = self.loadop 'JUMP_FORWARD' delta: 2  # one is on the stack already
  to_except!
  self.loadop 'ROT_TWO' delta: 0
  self.loadop 'DUP_TOP' delta: 1
  self.store_top name
  self.loadop 'ROT_TWO' delta: 0
  to_else!

  # The `switch` statement.
  # XXX is that considered "code duplication"?
  jumps = list $ map ((cond, action) ->
    next = self.loadop 'POP_JUMP_IF_FALSE' cond delta: 0
    end  = self.loadop 'JUMP_FORWARD'    action delta: 0
    next!
    end
  ) cases

  # This will re-raise the exception if nothing matched
  # (and there was an exception. And there is no `finally` clause.)
  self.loadop 'END_FINALLY' delta: -3

  # The problem is, now we need to POP_EXCEPT, but only
  # if there was a handled exception.
  # First, jump over this whole part if the exception was not handled.
  unhandled_exception = self.loadop 'JUMP_FORWARD' delta: 0

  # Second, point all `if` actions here, and temporarily store the result.
  list $ map call jumps
  self.loadop 'STORE_FAST' arg: '<except-result>' delta: 0
  # Third, if type is None, skip over POP_EXCEPT.
  self.loadop 'DUP_TOP' delta: 1
  self.loadop 'COMPARE_OP' None arg: 'is' delta: 0
  no_exception = self.loadop 'POP_JUMP_IF_TRUE' delta: -1
  self.loadop 'POP_EXCEPT' delta: 0
  no_exception!

  # Finally, restore the result.
  self.loadop 'LOAD_FAST' arg: '<except-result>' delta: 1
  self.loadop 'ROT_TWO' delta:  0
  self.loadop 'POP_TOP' delta: -1
  self.loadop 'STORE_FAST' arg: '<except-result>' None delta: 0
  unhandled_exception!

  has_finally =>
    # If the interpreter made it here, one of the `except` clauses matched.
    self.loadop 'POP_BLOCK' delta: -1
    self.load   None

    to_finally!
    self.loadop 'POP_TOP' finally delta: 0
    self.loadop 'END_FINALLY'     delta: 0

  # We should be left with a return value by now.
