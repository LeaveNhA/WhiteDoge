# Translate `a R b Q c` into `(a R b) and (b Q c)`
# iff both `R` and `Q` are comparison operators, but without
# evaluating `b` twice.
#
# (Yes, Python compiler generates the same bytecode.)
#
comparison = op -> (self f args chain: False) ->
  (a, b), _, _, _ = unpack f args 2 2

  double = a :: parse.tree.Expression and not a.closed and
    e, *ex = a
    e :: parse.tree.Link and e in PREFIX and
      f = PREFIX !! e
      # How do I check if that closure is the same as this one?
      getattr f '__code__' None is comparison.__code__.co_consts !! 0

  # Now `double` is true iff `a` is another comparison.
  # Also, `e`, `ex`, and `f` will be defined if that is the case.
  jumps = (f self e ex chain: True if double else list!)

  # If not, then `a` is a plain old boring expression.
  self.load a if not double

  switch
    chain = jumps.append $
      self.loadop 'DUP_TOP'          b   delta:  2  # [a, b]
      self.loadop 'ROT_THREE'            delta:  0  # [b, a, b]
      self.loadop 'COMPARE_OP' arg: op   delta: -1  # [b, a R b]
      self.loadop 'JUMP_IF_FALSE_OR_POP' delta: -1  # [b, True] if a R b else [b]

    True =
      self.load   b
      self.loadop 'COMPARE_OP' arg: op   delta: -1  # [a R b]
      # Now, what if one of the comparisons returned False?
      # First, we jump here.
      jumps and
        ontrue = self.loadop 'JUMP_FORWARD' delta: 0
        list $ map call jumps
        # Then we remove the unneeded item, leaving `False` on the stack.
        # (Stack size change was already accounted for by JUMP_IF_FALSE_OR_POP.)
        self.loadop 'ROT_TWO' delta: 0  # [False, b]
        self.loadop 'POP_TOP' delta: 0  # [False]
        ontrue!

  # Return the list of unfinished jumps for the next operator to use.
  jumps


PREFIX !! '<'  = comparison '<'
PREFIX !! '<=' = comparison '<='
PREFIX !! '==' = comparison '=='
PREFIX !! '!=' = comparison '!='
PREFIX !! '>'  = comparison '>'
PREFIX !! '>=' = comparison '>='
PREFIX !! 'is' = comparison 'is'
PREFIX !! 'in' = comparison 'in'
