import '/os'
import '/imp'
import '/sys'
import '/marshal'
import '/itertools'
import '/importlib/util' qualified

import '../../compile'


Loader = subclass object where
  __init__ = @pkg @path @ispkg ~> None
  get_filename = _ ~> @path
  is_package   = _ ~> @ispkg

  get_code = _ ~>
    cache = imp.cache_from_source @path
    code  = except
      e => (os.stat @path).st_mtime <= (os.stat cache).st_mtime and marshal.load (open cache 'rb')
      e :: Exception => None

    code or
      code = compile.fd $ open @path
      # not (os.environ.get PYTHONDONTWRITEBYTECODE '') =>
      os.makedirs (os.path.dirname cache) exist_ok: True
      marshal.dump code $ open cache 'wb'
      code

  find_module = classmethod $ name path: None ~> next $ call
    (pkg, _, name) ->
      for p in (path or sys.path) =>
        for (n, f) in ((os.path.join p name '__init__.dg', True), (os.path.join p name + '.dg', False)) =>
          if os.path.isfile n =>
            yield $ self pkg n f
      yield None
    name.rpartition '.'

  load_module = importlib.util.module_for_loader $ module ~>
    module.__file__    = @path
    module.__loader__  = self
    module.__package__ = @pkg
    @ispkg =>
      module.__path__    = list' $ os.path.dirname @path
      module.__package__ = module.__name__

    eval (@get_code None) module.__dict__

sys.meta_path.insert 0 Loader
