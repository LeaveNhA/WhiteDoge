import '/os'
import '/fcntl'
import '/struct'
import '/select'
import '/termios'
import '/contextlib'

import 'ansi/Sequence'


Teletype = subclass object where
  #: Various TTY-related functions.
  #:
  #: input  :: TextIOBase -- 'r'-mode TTY.
  #: output :: TextIOBase -- 'w'-mode TTY.
  #:
  __init__ = @input @output @name: None ~>
    not @input .isatty! => raise $ IOError 'input: not a tty'
    not @output.isatty! => raise $ IOError 'output: not a tty'
    None

  write = ~> @output.write
  flush = ~> while True => except
    err => @output.flush!
    err :: BlockingIOError => select.select [] [@output] []
    err is None => break!

  #: Determine the length of an ANSI-escaped string. ANSI escapes are assumed to be empty.
  #:
  #: ansi_len :: str -> int
  #:
  ansi_len = classmethod $ data ~> len $ Sequence.sub (m -> m.group 1 or '') data

  #: Check whether a key's value is printable.
  #:
  #: printable :: str -> bool
  #:
  printable = classmethod $ data ~> if
    len data == 0 => True
    len data == 1 => 32 <= ord data < 127 or 160 <= ord data

  #: Enter the raw mode of a TTY.
  #:
  #: raw :: bool bool -> context NoneType
  #:
  raw = contextlib.contextmanager $ jobctl flowctl ~>
    old = termios.tcgetattr @input
    new = termios.tcgetattr @input
    new !! 0 &= ~(termios.ISTRIP | termios.IXON)
    new !! 3 &= ~(termios.ECHO   | termios.ICANON | termios.IEXTEN | termios.ISIG)
    if flowctl => new !! 0 |= termios.IXON
    if jobctl  => new !! 3 |= termios.ISIG
    except _       => yield $ termios.tcsetattr @input termios.TCSADRAIN new
           finally =>         termios.tcsetattr @input termios.TCSAFLUSH old

  #: Enter the non-blocking mode of a TTY.
  #:
  #: nonblocking :: context NoneType
  #:
  nonblocking = property $ contextlib.contextmanager $ self ->
    flags = fcntl.fcntl @input fcntl.F_GETFL
    except _       => yield $ fcntl.fcntl @input fcntl.F_SETFL (flags | os.O_NONBLOCK)
           finally =>         fcntl.fcntl @input fcntl.F_SETFL flags

  #: Find out how much stuff this TTY can display at once.
  #:
  #: size :: (int, int) -- (height, width) in characters
  #:
  size = ~> struct.unpack 'hh' $ fcntl.ioctl @output termios.TIOCGWINSZ '1234'

  #: Read at most a line from a TTY (blocking until at least a character is available.)
  #:
  #: buffer :: float -> iter str
  #:
  buffer = timeout ~>
    x = @input.readline!
    x == '' =>
      has_data = fst $ if timeout   => select.select [@input] [] [] timeout
                          otherwise => select.select [@input] [] []
      x = @input.readline!
      x == '' and has_data => raise $ IOError 'input channel closed'
    map (x -> x.group!) $ Sequence.finditer x

  #: Move the caret `y` characters down and `x` characters to the right.
  #:
  #: relmove :: int int -> a
  #:
  relmove = y x ~> @write $ (+)
    if y > 0     => '\033[{}B'.format y
       y < 0     => '\033[{}A'.format (-y)
       otherwise => ''  # If `y` is 0, terminals might assume 1.
    if x > 0     => '\033[{}C'.format x
       x < 0     => '\033[{}D'.format (-x)
       otherwise => ''

  #: Erase everything from the cursor to the end of the screen.
  #:
  #: erase :: a
  #:
  erase = ~> @write '\033[J'
