import '/re'
import '/ast/literal_eval'
import '/collections/deque'


it = data filename: '<string>' ->
  '''Parse an input string.

    it :: str (Optional str) -> Node

  '''
  p = Parser data filename
  p.block (filename, 1, 1, head p.lines) (Dedent is) closed: False


fd = data filename: '<stream>' ->
  '''Parse the contents of a file-like object opened in text mode.

    Note that the `filename` argument is only used if the file-like object
    has no `name` attribute itself.

    fd :: TextIOBase (Optional str) -> Node
 
  '''
  it (data.read -1) (getattr data 'name' filename)


Node = subclass object where
  '''Generic AST node. No direct instances are found in the parser output.

    type Node {
      loc :: (str, int, int, str) -- (filename, line, character, first line)
      closed :: bool -- whether the node is parenthesized
      indent :: bool -- whether the node is an indented block
      infix  :: bool -- whether the node is infix between two other nodes
      nolhs  :: bool -- (infix = True) whether the node is, in fact, postfix
      norhs  :: bool -- (infix = True) same as `nolhs`, only prefix
      varary :: bool -- (infix = True) whether `a R b R c` constructs only one `R`
      spec_a :: bool -- whether this node is `R` in `R a => b` syntactic construct
      spec_b :: bool -- whether this node consumes everything until the
                     -- end of the line as the first funcall argument.
    }

  '''
  __init__ = *: args **: kwargs ~>
    @loc    = kwargs.pop 'at'     None
    @closed = kwargs.pop 'closed' False
    @indent = kwargs.pop 'indent' False
    @infix  = kwargs.pop 'infix'  False
    @nolhs  = kwargs.pop 'nolhs'  False
    @norhs  = kwargs.pop 'norhs'  False
    @varary = kwargs.pop 'varary' False
    @spec_a = kwargs.pop 'spec_a' False
    @spec_b = kwargs.pop 'spec_b' False
    @init *: args **: kwargs
    None

  __repr__ = self -> if @closed   => '({})'.format @repr
                        otherwise =>               @repr

  init = ~> raise $ TypeError 'instantiating Node directly is pointless'
  repr = ~> 'nil'


Name = subclass Node where
  '''An identifier.

    The only kind of `Node` that can have anything
    other than `closed` or `indent` set to `True`.

    type Name < Node {
      value :: str
    }

  '''
  init   = @value ~>
  repr   =        ~> @value
  __eq__ =      x ~> @value == x

  __gt__ = over strength: (dict'
    '@',     ( 5,    5)    # attribute of `self`
    '.',     ( 0,    0)    # getattr
    '!.',    ( 0,    0)    # call with no arguments, then getattr
    '!',     ( 0,   -10)   # call with no arguments
    ':',     ( 0,   -10)   # keyword argument
    '',      (-20,  -20)   # call with an argument
    '!!',    (-30,  -30)   # container subscription (i.e. `a[b]`)
    '**',    (-30,  -40)   # exponentiation
    '*',     (-50,  -50)   # multiplication
    '/',     (-50,  -50)   # fp division
    '//',    (-50,  -50)   # int division
    '%',     (-50,  -50)   # modulus
    '+',     (-60,  -60)   # addition
    '-',     (-60,  -60)   # subtraction
    '<',     (-80,  -80)   # less than
    '<=',    (-80,  -80)   # ^ or equal
    '>',     (-80,  -80)   # greater than
    '>=',    (-80,  -80)   # ^ or equal
    '==',    (-80,  -80)   # equal
    '!=',    (-80,  -80)   # not ^
    'is',    (-80,  -80)   # occupies the same memory location as
    'in',    (-80,  -80)   # is one of the elements of
    '<<',    (-100, -100)  # *  2 **
    '>>',    (-100, -100)  # // 2 **
    '&',     (-110, -110)  # bitwise and
    '^',     (-120, -120)  # bitwise xor
    '|',     (-130, -130)  # bitwise or
    'and',   (-140, -140)  # B if A else A
    'or',    (-150, -150)  # A if A else B
    '$',     (-150, -160)  # call with one argument and no f-ing parentheses
    '->',    (-25,  -180)  # a function
    '~>',    (-25,  -180)  # a method (i.e. a function with `self` as an argument)
    ',',     (-170, -170)  # a tuple
    '=',     (-170, -180)  # assignment
    '!!=',   (-170, -180)  # in-place versions of some of the other functions
    '+=',    (-170, -180)
    '-=',    (-170, -180)
    '*=',    (-170, -180)
    '**=',   (-170, -180)
    '/=',    (-170, -180)
    '//=',   (-170, -180)
    '%=',    (-170, -180)
    '&=',    (-170, -180)
    '^=',    (-170, -180)
    '|=',    (-170, -180)
    '<<=',   (-170, -180)
    '>>=',   (-170, -180)
    'where', (-170, -180)  # with some stuff that is not visible outside of that expression
    'for',   (-180, -190)  # evaluate stuff for each item in an iterable
    'while', (-180, -190)  # evaluate stuff until condition becomes false
    '=>',    (-180, -190)  # if-then
    '\n',    (-230, -230)  # do A then B
  ).get default: (-70, -70) ~>
    '''Whether this (infix) node has priority over the other one.

      `a R b Q c` <=> `a R (b Q c)` if left binding strength of `Q`
      is higher than right binding strength of `R`, `(a R b) Q c` otherwise.

      Name > Name -> bool

    '''
    strength @value default !! 0 > strength over.value default !! 1


Expression = subclass Node where
  '''A single function call.

    If the function in question is prefix, `op` will be `''`.

    type Expression < Node {
      op   :: Node   -- function
      args :: [Node] -- arguments

      op.infix is True
      not op.varary => len args == 2
          op.varary => len args >= 2
    }

  '''
  init = @op *: args ~> (@args = list args)
  repr =             ~> (' {!r} ' .format @op).join $ map repr @args


Constant = subclass Node where
  '''A marshallable compile-time constant.

    type Constant < Node {
      value :: Either int float complex str
    }

  '''
  init   = @value ~>
  repr   =        ~> repr @value
  __eq__ =      x ~> x :: Constant and @value == x.value


LeftBind = subclass Expression where
  '''An infix expression missing its right part.

    type LeftBind < Expression {
      len args == 1
    }

  '''
  repr = ~> '{[0]!r} {!r}'.format @args @op


RightBind = subclass Expression where
  '''An infix expression missing its left part.

    type RightBind < Expression {
      len args == 1
    }

  '''
  repr = ~> '{!r} {[0]!r}'.format @op @args


Ending = subclass Constant where
  '''A signal for `Parser.block` to stop reading `Node`s.

    The string `value` will be different depending on the type of
    close-paren. Does not appear in parser output.

    type Ending < Constant {
      value :: str
    }

  '''

Dedent = Ending ''


Parser = subclass deque where
  '''A recursive descent parser with a built-in regex-based tokenizer.

    type Parser < deque {
      tokens :: iter MatchObject -- see `regex`.
      indent :: deque int -- a stack of indentation levels, starting with 0.
      lineno :: int -- 1-based line number.
      charno :: int -- 1-based character number.
      lines  :: list str -- the input, split at line breaks.
    }

  '''
  __init__ = @data @filename ~>
    @tokens  = @regex.finditer @data
    @indent  = deque $ list' 0
    @lineno  = 1
    @charno  = 1
    @lines   = @data.split '\n'
    None

  __iter__ = self -> self
  __next__ = self ->
    if self => @popleft!
       otherwise => except
         e =>
           m   = next @tokens
           g   = m.group!
           pos = @filename, @lineno, @charno, @lines !! (@lineno - 1)

           '\n' in g => @charno = -g.rfind '\n'
           @charno += len g
           @lineno += g.count '\n'
           @token pos m.lastgroup m

         e :: StopIteration => Dedent

  # regex :: Re
  #
  # A big regex used to tokenize input text. Each top-level group
  # must have a handling branch in `token`, else `SyntaxError` is raised.
  #
  regex = re.compile r'''(?isx)
    (?P<space>  [^\S\n]+|\s*\#[^\n]*)
   |(?P<const>  [+-]?(?:0b[0-1]+|0o[0-7]+|0x[0-9a-f]+|[0-9]+(?:\.[0-9]+)?(?:e[+-]?[0-9]+)?j?))
   |(?P<str>    (?P<flags>br|r?b?)(?P<quote>['"]{3}|['"])(?P<content>(?:\\?.)*?)\5)
   |(?P<name>   \w+'*|\*+(?=:)|([!$%&*+\--/:<-@\\^|~;]+)|(,+)|\s*(\n)(\ *)|`(\w+'*)`)
   |(?P<block>  \()
   |(?P<end>    \))
   |(?P<strerr> ['"])
   |.
  '''

  # `Name`s that have the corresponding flags set.
  # (`infixn` -> `infix`, but there's a method with that name below.)
  spec_a = set' 'for' 'while' 'with'
  spec_b = set' 'if' 'except'
  nolhs  = set' '@' '~'
  norhs  = set' '!'
  infixn = set' 'and' 'in' 'is' 'or' 'where'

  token = pos f m ~>
    '''Handle a single regex match.

      token :: (str, int, int, str) str MatchObject -> Node

    '''
    if f == 'space' => next self
       f == 'const' => Constant at: pos $ literal_eval $ m.group 0
       f == 'str'   => Constant at: pos $ literal_eval $
         x = 3 * m.group 'quote' !! 0
         m.group 'flags' + x + m.group 'content' + x

       f == 'name' =>
         x, a, b, c, d, e = m.group 7 8 9 10 11 12

         c =>
           # Handling indentation here is more efficient.
           pos2  = @filename, @lineno, @charno, @lines !! (@lineno - 1)
           level = len d

           level > last @indent =>
             @indent.append level
             @appendleft $ @block pos closed: False $ x ->
               x :: Ending => x is Dedent or
                 # Indented blocks can be ended with close-parens.
                 # We have to account for a decrease in indentation, though.
                 @indent.pop!
                 # This may not be the only indented block that've ended.
                 # A parenthesized one will take `x` off the stack.
                 @appendleft x
               x :: Ending

           # `level >  last @indent` => the indented block was ended by a close-paren.
           # `level == last @indent` => we're still parsing it.
           while level < last @indent =>
             @indent.pop!
             @appendleft $ Name '\n' infix: True varary: True at: pos2
             @appendleft $ Dedent
             last @indent < level => @error 'no matching indentation level' pos

         Name (c or e or x) at: pos
           infix:  (bool $ a or b or c or e or x in infixn)
           varary: (bool $ b or c)
           nolhs:  (a in nolhs)
           norhs:  (a in norhs)
           spec_a: (x in spec_a)
           spec_b: (x in spec_b)

       f == 'block'  => @block pos (Ending ')' ==)
       f == 'end'    => Ending ')' at: pos
       f == 'strerr' => @error 'unexpected EOF while reading a string literal' pos
       otherwise     => @error 'invalid character'                             pos

  block = pos end closed: True ~>
    '''Read tokens until the end of the block.

      pos -- (filename, lineno, charno, first line) of this block.
      end -- returns True if a `Node` is an acceptable block end.
      closed -- whether the block is encased in hard parentheses.

      block :: (str, int, int, str) (Node -> bool) (Optional bool) -> Node

    '''
    result = Constant None at: pos
    isexpr = False
    x      = next self

    while not $ end x =>
      if x is Dedent => @error 'unexpected EOF in a block'          pos
         x :: Ending => @error 'this block was not closed properly' pos

         isexpr    => result = @infix (Name '' infix: True varary: True at: x.loc) result x
         x != '\n' => result, isexpr = @special x, True
      x = next self

    result.closed |= closed
    result.indent  = not closed
    result

  infix = op lhs rhs ~>
    '''Combine two parts of a tree with an infix `Name`.

      op  -- something to combine with.
      lhs -- everything to the left.
      rhs -- next `Node` to the right.

      infix :: Name Node Node -> Node

    '''
    br = False

    not op.norhs => while rhs == '\n' =>
      # There are some special cases for indented rhs,
      # so we'll have to ignore the line breaks for now.
      br, rhs = rhs, next self

    rhs.nolhs and not rhs.closed =>
      # Got to handle that first, as the empty operator may not have
      # enough binding strenght for that later.
      rhs = @infix (Name '' infix: True varary: True at: rhs.loc) rhs $ next self

    if
      rhs :: Ending or op.norhs =>
        @appendleft rhs
        op != '' => lhs = @infixin op lhs None
        lhs

      br and not rhs.indent =>
        op != '' => lhs = @infixin op lhs None
        @infixin br lhs rhs

      rhs.infix and not rhs.closed and (op == '' or not (rhs > op)) =>
        op != '' => lhs = @infixin op lhs None
        @infix rhs lhs $ next self

      otherwise => @infixin op lhs rhs

  infixin = op lhs rhs ~>
    '''Recursively descend into `lhs` to apply infix precedence rules.

      `rhs` may be `None` if there is none.

      infixin :: Name Node (Maybe Node) -> Expression

    '''
    if
      lhs :: Expression and not lhs.closed and op > lhs.op =>
        lhs.args.append $ @infixin op (lhs.args.pop -1) rhs
        lhs

      rhs is None =>
        LeftBind op lhs closed: True at: lhs.loc

      lhs :: Expression and not lhs.closed and op.varary and op == lhs.op =>
        lhs.args.extend $ tail (@make_call op lhs rhs).args
        lhs

      op == '' and lhs.infix and not lhs.closed =>
        RightBind lhs at: lhs.loc $ if (Name '' > lhs => @special rhs) (otherwise => rhs)

      otherwise => @make_call op lhs rhs

  make_call = op lhs rhs ~>
    '''Create a simple function call. (Almost) no fancy rules.

      `rhs` can't be `None` once again. Handle that in some other way.

      make_call :: Name Node Node -> Expression

    '''
    if
      op == '' and not rhs.closed and rhs :: Expression and rhs.op == '\n' =>
        # In an indented block after an empty name, each statement
        # is a separate RHS.
        Expression op lhs *: rhs.args at: lhs.loc

      otherwise =>
        Expression op lhs at: lhs.loc $ if (Name '' > op => @special rhs) (otherwise => rhs)

  special = x ~>
    '''Handle a couple of fancy syntactic constructs.

      Suppose we have `x == Name "yoba"`. Then:
        condition  | syntax        | result
        -----------+---------------+------------------------------------
        x.spec_a   | yoba a => b   | Expression (Name 'yoba') a b
        -----------+---------------+------------------------------------
        x.spec_b   | yoba a => b   | Expression (Name '') (Name 'yoba')
                   |      c => d   |    Expression (Name '=>') a b
                   |      e => f   |    Expression (Name '=>') c d
                   |               |    Expression (Name '=>') e f
                   | (here, `a => b` may be omitted.)

      special :: Node -> Node

    '''
    x.spec_a =>
      x = @infix x (@block x.loc ('=>' ==)) (next self)

    x.spec_b =>
      arg = @block x.loc $ y ->
        end = y :: Ending or y == '\n'
        end => @appendleft y
        end

      arg != Constant None =>
         x = @infix (Name '' infix: True varary: True at: arg.loc) x arg

    x

  error = description at ~> raise $ SyntaxError description at
